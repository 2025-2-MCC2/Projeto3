<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="./public/logos/liderancas-empaticas.png" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Montserrat:wght@700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gestão de Lideranças</title>
    <!-- React 18 UMD + Babel Standalone (dev) -->
    <script>window.ENV = { NODE_ENV: 'development' };</script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Runtime ENV (copie env.js.example para env.js e ajuste API_URL) -->
    <script src="./env.js"></script>
    <style>
      :root {
        --green: #1f9d74;
        --green-dark: #0b6046;
        --green-neon: #4df2c2;
        --bg-hero: radial-gradient(circle at 10% 20%, rgba(77, 242, 194, 0.22), rgba(12, 27, 16, 0)), linear-gradient(160deg, rgba(6, 17, 12, 0.92) 0%, #04120c 38%, #051b12 100%);
        --card-bg: rgba(255,255,255,0.08);
        --card-border: rgba(255,255,255,0.08);
        --glass-blur: saturate(180%) blur(20px);
        --text-primary: #e9fef6;
        --text-muted: rgba(233, 254, 246, 0.62);
        --shadow-soft: 0 26px 64px rgba(5, 20, 14, 0.24);
        --shadow-hover: 0 32px 86px rgba(5, 20, 14, 0.3);
        --radius-md: 18px;
        --radius-lg: 28px;
        --space-sm: 0.75rem;
        --space-md: 1.25rem;
        --space-lg: 2.2rem;
        --transition: all .28s ease;
      }
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: #040d09;
        font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial;
        color: var(--text-primary);
        min-height: 100vh;
        background-image: url('https://www.transparenttextures.com/patterns/asfalt-dark.png');
        overflow-x: hidden;
        font-size: 16px;
        line-height: 1.6;
        letter-spacing: 0.01em;
      }
      header {
        position: sticky;
        top: 0;
        z-index: 1000;
        background: rgba(4, 18, 12, 0.86);
        backdrop-filter: blur(20px);
        border-bottom: 1px solid rgba(77, 242, 194, 0.18);
        padding: 22px 48px;
        display:flex;
        justify-content: space-between;
        align-items:center;
        font-family: 'Montserrat', sans-serif;
        font-weight:700;
        letter-spacing: 0.12em;
        transition: var(--transition);
      }
      header span:first-child {
        font-size: 20px;
        display:flex;
        align-items:center;
      }
      .header-actions {
        display:flex;
        gap:20px;
        align-items:center;
        font-size: 0.95rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }
      .container {
        max-width: 1220px;
        margin: 0 auto;
        padding: var(--space-lg) var(--space-md);
        display: grid;
        gap: var(--space-lg);
      }
      .grid-2 {
        display: grid;
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
        gap: var(--space-lg);
      }
      @media (max-width: 900px) { .grid-2 { grid-template-columns: 1fr; } }
      .card {
        background: rgba(4, 18, 12, 0.88);
        border: 1px solid rgba(233, 254, 246, 0.08);
        border-radius: var(--radius-lg);
        padding: var(--space-lg);
        box-shadow: var(--shadow-soft);
        backdrop-filter: var(--glass-blur);
        position: relative;
        overflow: hidden;
        transition: var(--transition);
      }
      .card::after {
        content: '';
        position: absolute;
        inset: 1px;
        border-radius: calc(var(--radius-lg) - 4px);
        border: 1px solid rgba(77, 242, 194, 0.05);
        pointer-events: none;
      }
      .btn {
        background: linear-gradient(125deg, var(--green) 0%, var(--green-neon) 100%);
        color:#05130c;
        border:none;
        padding: 1rem 1.8rem;
        border-radius: var(--radius-lg);
        font-weight: 600;
        font-size: 1rem;
        cursor:pointer;
        display:inline-flex;
        align-items:center;
        justify-content:center;
        gap:8px;
        box-shadow: none;
        font-family: inherit;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        font-size: 0.95rem;
        text-decoration:none;
        transition: var(--transition);
      }
      .btn:hover {
        transform: translateY(-2px);
        box-shadow: none;
        opacity: 0.9;
      }
      .btn:active {
        transform: scale(0.97);
        box-shadow: none;
      }
      /* Modern dashboards: utilities */
      .grid-auto { display:grid; grid-template-columns: repeat(12, minmax(0,1fr)); gap: var(--space-md); }
      .col-3 { grid-column: span 3; }
      .col-4 { grid-column: span 4; }
      .col-6 { grid-column: span 6; }
      .col-8 { grid-column: span 8; }
      .col-12 { grid-column: 1 / -1; }
      @media (max-width: 1200px){ .col-3{grid-column: span 6;} .col-4{grid-column: span 6;} .col-6{grid-column: span 12;} .col-8{grid-column: span 12;} }
      @media (max-width: 900px){ .col-3{grid-column: span 12;} .col-4{grid-column: span 12;} }
      .badge {
        display:inline-flex;
        align-items:center;
        gap:8px;
        padding:6px 14px;
        border-radius:999px;
        font-size:12px;
        background: rgba(77, 242, 194, 0.14);
        color: var(--green-neon);
        border:1px solid rgba(77, 242, 194, 0.34);
        text-transform: uppercase;
        letter-spacing: 0.12em;
      }
      .chip {
        padding:6px 14px;
        border-radius:999px;
        background: rgba(255,255,255,0.08);
        color: var(--text-primary);
        font-size:12px;
        border:1px solid rgba(255,255,255,0.14);
        letter-spacing: 0.08em;
      }
      .risk-badge {
        display:inline-flex;
        align-items:center;
        gap:8px;
        border-radius:999px;
        padding:4px 10px;
        font-size:11px;
        letter-spacing:0.4px;
        text-transform:uppercase;
        background: rgba(255,255,255,0.06);
        border:1px solid rgba(255,255,255,0.08);
      }
      .risk-badge svg { width:14px; height:14px; }
      .risk-low { color:#4df2c2; border-color:rgba(77, 242, 194, 0.4); background: rgba(77, 242, 194, 0.08); }
      .risk-medium { color:#ffd45f; border-color:rgba(255,212,95,0.45); background: rgba(255,212,95,0.12); }
      .risk-high { color:#ff7b7b; border-color:rgba(255,123,123,0.4); background: rgba(255,123,123,0.12); box-shadow:0 0 14px rgba(255,123,123,0.18); }
      .audit-timeline {
        display:flex;
        flex-direction:column;
        gap:12px;
        margin-top:12px;
      }
      .audit-timeline-item {
        display:grid;
        grid-template-columns: 18px 1fr;
        gap:12px;
        align-items:start;
      }
      .audit-timeline-item span {
        font-size:12px;
        color: rgba(233,254,246,0.65);
      }
      .audit-icon {
        width:18px;
        height:18px;
        border-radius:50%;
        background: rgba(77,242,194,0.16);
        border:1px solid rgba(77,242,194,0.42);
        display:flex;
        align-items:center;
        justify-content:center;
        font-size:10px;
        color:var(--green-neon);
      }
      .audit-divider {
        height:1px;
        background:rgba(77,242,194,0.12);
      }
      .muted { color: var(--text-muted); }
      .subtitle {
        color:#f0fff8;
        font-weight:600;
        letter-spacing:0.14em;
        text-transform: uppercase;
        font-size: 0.95rem;
      }
      .btn-full { width:100%; }
      .login-wrapper {
        min-height: 100vh;
        background: var(--bg-hero);
        padding: 64px 24px;
        display:flex;
        align-items:center;
        justify-content:center;
        position:relative;
        overflow:hidden;
      }
      .login-wrapper::before,
      .login-wrapper::after {
        content:'';
        position:absolute;
        border-radius: 50%;
        filter: blur(120px);
        opacity:0.35;
        pointer-events:none;
      }
      .login-wrapper::before {
        width: 420px;
        height: 420px;
        background: rgba(77, 242, 194, 0.35);
        top: -120px;
        right: -160px;
      }
      .login-wrapper::after {
        width: 360px;
        height: 360px;
        background: rgba(31, 157, 116, 0.32);
        bottom: -140px;
        left: -140px;
      }
      .login-card {
        width: 100%;
        max-width: 540px;
        padding: 54px 48px;
        background: rgba(4, 18, 12, 0.9);
        border: 1px solid rgba(77, 242, 194, 0.2);
        box-shadow: 0 40px 140px rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(24px);
        border-radius: 30px;
        transition: var(--transition);
      }
      .login-header {
        display:flex;
        flex-direction:column;
        align-items:center;
        justify-content:center;
        gap:20px;
        margin-bottom: 40px;
        text-align:center;
      }
      .login-logos {
        display:flex;
        gap:24px;
        align-items:center;
        justify-content:center;
        margin-bottom: 20px;
      }
      .login-logos img {
        height: 78px;
        width: 78px;
        object-fit: contain;
        padding: 0;
        border-radius: 0;
        background: transparent;
        border: none;
        box-shadow: none;
        display: block;
      }
      .login-title {
        text-align: center;
        margin-bottom: 0;
        font-size: 1.3rem;
        font-weight: 700;
        color: #f4fff8;
        letter-spacing: -0.04em;
        white-space: nowrap;
        max-width: 100%;
        line-height: 1.2;
        padding: 0 5px;
        overflow: visible;
      }
      .login-subtitle {
        font-size: 0.85rem;
        letter-spacing: 0.05em;
        color: rgba(233, 254, 246, 0.7);
        text-transform: uppercase;
        white-space: nowrap;
        max-width: 100%;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .login-form {
        display:grid;
        gap: var(--space-md);
      }
      .login-form .input {
        border-radius: var(--radius-md);
        padding: 1rem 1.2rem;
        width: 100%;
        box-sizing: border-box;
      }
      .login-error {
        color: #ff6b6b;
        text-align: center;
        font-size: 0.92rem;
        letter-spacing: 0.3px;
      }
      .login-form select.input {
        appearance: none;
        padding-right: 48px;
        background-image:
          linear-gradient( to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,0) 60%, rgba(0,0,0,0.18) 100%),
          url('data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="%234df2c2" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"%3E%3Cpolyline points="6 9 12 15 18 9"/%3E%3C/svg%3E');
        background-position: 0 0, calc(100% - 18px) 50%;
        background-size: 100% 100%, 18px 18px;
        background-repeat: no-repeat;
      }
      .login-actions {
        margin-top: 24px;
        display:grid;
        gap:16px;
      }
      .login-switch {
        text-align:center;
      }
      .login-switch .btn {
        border-radius:999px;
        border:1px solid rgba(77, 242, 194, 0.28);
        background: rgba(4, 18, 12, 0.65);
        color: var(--green-neon);
        box-shadow: none;
      }
      .login-switch .btn:hover {
        background: rgba(77, 242, 194, 0.18);
        color: #05130c;
      }
      .divider { height:1px; background:#eef1f3; margin:8px 0; }
      .btn-sm { padding:6px 10px; border-radius:999px; font-size: 0.92rem; }
      .btn-ghost {
        background:rgba(77, 242, 194, 0.12);
        color: var(--green-neon);
        border:1px solid rgba(77, 242, 194, 0.32);
      }
      .btn-ghost:hover {
        background: rgba(77, 242, 194, 0.18);
        color: #05130c;
      }
      .btn-danger {
        background: linear-gradient(135deg, #f15f79 0%, #b24592 100%);
        color:#fff;
        box-shadow: none;
      }
      .input {
        padding:0.95rem 1.2rem;
        border:1px solid rgba(233, 254, 246, 0.14);
        border-radius: var(--radius-md);
        width:100%;
        background: rgba(4, 18, 12, 0.92);
        color: var(--text-primary);
        box-shadow: inset 0 0 0 1px rgba(77, 242, 194, 0.06);
        transition: var(--transition);
      }
      .input:hover {
        border-color: rgba(77, 242, 194, 0.28);
      }
      .input:focus {
        outline:none;
        border-color: var(--green-neon);
        box-shadow: 0 0 0 6px rgba(77, 242, 194, 0.16);
        transform: translateY(-1px);
      }
      .input::placeholder {
        color: rgba(233, 254, 246, 0.36);
      }
      table {
        width:100%;
        border-collapse: collapse;
        color: inherit;
      }
      th, td {
        padding:12px 10px;
        text-align:left;
      }
      thead tr {
        background: rgba(12, 26, 18, 0.7);
        border-bottom: 1px solid rgba(77, 242, 194, 0.14);
      }
      tbody tr {
        border-top: 1px solid rgba(77, 242, 194, 0.08);
      }
      .linha-selecionada { background-color: #d1ecf1; font-weight: bold; }
      button:disabled { opacity: 0.5; cursor: not-allowed; }
      /* Animations */
      @keyframes fadeInUp { from { opacity: 0; transform: translateY(16px); } to { opacity: 1; transform: translateY(0); } }
      @keyframes scaleIn { from { opacity: 0; transform: scale(.96); } to { opacity: 1; transform: scale(1); } }
      .anim-fade { animation: fadeInUp .5s ease both; }
      .anim-scale { animation: scaleIn .4s ease both; }
      /* Auth styles */
      .auth-bg {
        background: var(--bg-hero);
      }
      .auth-grid {
        display:grid;
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
        gap: 0;
        width:100%;
        max-width: 1060px;
        border-radius: 26px;
        overflow: hidden;
        box-shadow: 0 40px 120px rgba(0,0,0,0.45);
      }
      .auth-col-illustration {
        display:none;
        background: linear-gradient(200deg, rgba(77, 242, 194, 0.24), rgba(4, 15, 10, 0.9));
        padding:48px;
        position:relative;
      }
      .auth-col-illustration::after {
        content:'';
        position:absolute;
        inset:24px;
        border-radius: 38px;
        border: 1px solid rgba(77, 242, 194, 0.2);
        opacity:0.6;
      }
      .auth-card {
        background: rgba(4, 18, 12, 0.82);
        border:1px solid rgba(77, 242, 194, 0.16);
        padding:48px 40px;
        backdrop-filter: blur(16px);
      }
      @media (min-width: 960px){ .auth-col-illustration{display:block;} }
      .input-group { position: relative; }
      .input-icon { position:absolute; left:10px; top:50%; transform:translateY(-50%); color:#6c757d; }
      .input.has-icon { padding-left:34px; }
      .link-ghost { background:transparent; color: var(--green); border:none; cursor:pointer; padding:6px 8px; border-radius:8px; }
      .link-ghost:hover { background: rgba(25,135,84,.06); }
      .text-center { text-align:center; }
      .row { display:flex; gap:12px; align-items:center; justify-content:space-between; }
      .help { font-size:12px; color:#6c757d; }
      /* Animações e interações suaves */
      @keyframes slideIn { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }
      @keyframes popIn { from { opacity: 0; transform: scale(.92); } to { opacity: 1; transform: scale(1); } }
      @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
      @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
      @keyframes barRise { from { transform: scaleY(0); opacity: 0; } to { transform: scaleY(1); opacity: 1; } }
      @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
      @keyframes glow { 0% { box-shadow: 0 0 5px rgba(77, 242, 194, 0.4); } 50% { box-shadow: 0 0 20px rgba(77, 242, 194, 0.8); } 100% { box-shadow: 0 0 5px rgba(77, 242, 194, 0.4); } }
      
      .anim-slide { animation: slideIn .5s ease both; }
      .pulse { animation: pulse 1.5s infinite; }
      .anim-fade { animation: fadeIn 0.6s ease forwards; }
      .anim-pop { animation: popIn 0.4s cubic-bezier(0.22, 1, 0.36, 1) forwards; }
      
      /* Estilos para os cartões de estatísticas */
      .stat-card {
        position: relative;
        background: var(--card-bg);
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: hidden;
        height: 100%;
        border-left: 4px solid #4df2c2;
      }
      
      .stat-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
      }
      
      .stat-card .stat-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 48px;
        height: 48px;
        border-radius: 12px;
        margin-bottom: 16px;
        font-size: 20px;
        transition: all 0.3s ease;
      }
      
      .stat-card:hover .stat-icon {
        transform: scale(1.1) rotate(5deg);
      }
      
      .stat-card .stat-value {
        font-size: 28px;
        font-weight: 700;
        margin: 8px 0 4px;
        transition: color 0.3s ease;
      }
      
      .stat-card .stat-description {
        font-size: 14px;
        color: var(--text-muted);
        transition: color 0.3s ease;
      }
      
      .stat-card .stat-badge {
        position: absolute;
        top: 12px;
        right: 12px;
        font-size: 10px;
        font-weight: 600;
        padding: 3px 8px;
        border-radius: 12px;
        background: rgba(77, 242, 194, 0.2);
        color: #4df2c2;
        transition: all 0.3s ease;
      }
      
      .stat-card:hover .stat-badge {
        transform: scale(1.05);
        opacity: 0.9;
      }
      
      .stat-card .pulse-dot {
        position: absolute;
        top: 12px;
        right: 12px;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #ff3b30;
        box-shadow: 0 0 0 0 rgba(255, 59, 48, 0.7);
      }
      
      .stat-card .pulse-dot.active {
        animation: pulse 1.5s infinite;
      }
      
      /* Estilos para cartões de estatísticas */
      .stat-card {
        transition: all 0.3s ease;
        border-radius: 12px;
        padding: 20px;
        background: var(--card-bg);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        border-left: 4px solid var(--green-neon);
        height: 100%;
      }
      
      .stat-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
        background: rgba(77, 242, 194, 0.05);
      }
      
      .stat-icon {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        background: rgba(77, 242, 194, 0.1);
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 16px;
        transition: all 0.3s ease;
      }
      
      .stat-card:hover .stat-icon {
        transform: rotate(10deg) scale(1.1);
        background: rgba(77, 242, 194, 0.2);
      }
      
      .stat-value {
        font-size: 28px;
        font-weight: 700;
        margin: 8px 0 4px;
        transition: all 0.3s ease;
      }
      
      .stat-card:hover .stat-value {
        color: var(--green-neon);
      }
      
      .stat-label {
        color: var(--text-muted);
        font-size: 14px;
        transition: all 0.3s ease;
      }
      
      /* Estilos para gráficos */
      .chart-container {
        background: var(--card-bg);
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        transition: all 0.3s ease;
      }
      
      .chart-container:hover {
        box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
      }
      
      .chart-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
      }
      
      .chart-title {
        font-size: 16px;
        font-weight: 600;
        color: var(--text-primary);
        margin: 0;
      }
      
      /* Tooltip personalizado */
      .tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 14px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
        z-index: 100;
        max-width: 200px;
        text-align: center;
      }
      
      /* Spinner de carregamento */
      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid rgba(77, 242, 194, 0.2);
        border-top: 4px solid var(--green-neon);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 20px auto;
      }
      
      /* Efeito de hover nas barras do gráfico */
      .bar {
        position: relative;
        transition: all 0.3s ease;
        animation: barRise 0.6s ease-out forwards;
        transform-origin: bottom;
      }
      
      .bar:hover {
        opacity: 0.9 !important;
        transform: translateY(-2px) !important;
      }
      .anim-pop { animation: popIn .35s ease both; }
      .reveal { opacity: 0; transform: translateY(14px); transition: opacity .5s ease, transform .5s ease; }
      .reveal.in-view { opacity: 1; transform: none; }

      .card { transition: var(--transition); }
      .card:hover { transform: translateY(-4px); box-shadow: var(--shadow-hover); }
      .btn { transition: var(--transition); }
      tbody tr { transition: var(--transition); }
      tbody tr:hover {
        transform: translateY(-2px);
        background: rgba(77, 242, 194, 0.06);
      }

      @media (prefers-reduced-motion: reduce) {
        * { animation: none !important; transition: none !important; }
      }

      /* Mobile-first enhancements (only phones/tablets) */
      @media (max-width: 768px) {
        body { font-size: 15px; }
        header {
          padding: 14px 18px;
          flex-direction: column;
          align-items: flex-start;
          gap: 12px;
        }
        header span:first-child { font-size: 18px; }
        .header-actions {
          width: 100%;
          justify-content: space-between;
          flex-wrap: wrap;
          gap: 10px;
        }
        .container { padding: 18px; }
        .card { padding: 18px; border-radius: 18px; }
        .login-wrapper { padding: 36px 18px; }
        .login-card { padding: 36px 28px; }
        .login-header { gap:16px; margin-bottom:24px; }
        .login-logos { gap:18px; }
        .login-logos img { height:64px; width:64px; }
        .login-title { font-size: 18px; }
        .login-subtitle { font-size: 13px; }
        .login-form { gap:14px; }
        .login-form .input { padding: 15px 18px; }
        .login-actions { gap:12px; }
        .grid-auto { grid-template-columns: 1fr; gap: 12px; }
        .col-3, .col-4, .col-6, .col-8, .col-12 { grid-column: 1 / -1; }
        table { font-size: 14px; table-layout: fixed; }
        th, td { padding: 6px; white-space: nowrap; }
        .btn { padding: 10px 12px; border-radius: 10px; }
        .auth-logo-lg { height: 44px !important; }
        .auth-logo-sm { height: 36px !important; }
        /* Inputs larger to avoid iOS zoom */
        .input { font-size: 16px; }
        /* Collapse multi-column forms */
        form[style*='grid-template-columns:repeat(4'] { grid-template-columns: 1fr !important; }
        form[style*='grid-template-columns:repeat(3'] { grid-template-columns: 1fr !important; }
        /* Compact previews */
        img[alt^='Foto '] { width: 56px !important; height: 56px !important; }
      }

      @media (max-width: 540px) {
        header span:first-child { font-size: 17px; }
        .header-actions { justify-content: flex-start; }
        .login-wrapper { padding: 28px 16px; }
        .login-card { padding: 30px 22px; }
        .login-logos { gap:14px; }
        .login-logos img { height:58px; width:58px; }
        .login-title { font-size: 14px; }
        .login-subtitle { font-size: 12px; letter-spacing: 0.3px; }
        .login-form .input { padding: 14px 16px; }
        .btn { width: 100%; }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useEffect, useRef } = React;
      
      // Sistema de roteamento simples e funcional
      const Router = {
        currentRoute: window.location.hash.slice(1) || '/login',
        listeners: [],
        
        navigate(path) {
          window.location.hash = path;
          this.currentRoute = path;
          this.notifyListeners();
        },
        
        listen(callback) {
          this.listeners.push(callback);
          return () => {
            this.listeners = this.listeners.filter(l => l !== callback);
          };
        },
        
        notifyListeners() {
          this.listeners.forEach(callback => callback(this.currentRoute));
        }
      };
      
      // Hook para usar o roteamento
      function useRouter() {
        const [route, setRoute] = useState(Router.currentRoute);
        
        useEffect(() => {
          const unlisten = Router.listen(setRoute);
          
          const handleHashChange = () => {
            const newRoute = window.location.hash.slice(1) || '/login';
            Router.currentRoute = newRoute;
            setRoute(newRoute);
          };
          
          window.addEventListener('hashchange', handleHashChange);
          
          return () => {
            unlisten();
            window.removeEventListener('hashchange', handleHashChange);
          };
        }, []);
        
        return { route, navigate: Router.navigate.bind(Router) };
      }

      // Serviço de API com JWT
      class ApiService {
        constructor() {
          this.baseURL = (window.__ENV && window.__ENV.API_URL) || 'http://localhost:3001';
        }

        getAuthHeaders() {
          const token = localStorage.getItem('auth_token');
          return {
            'Content-Type': 'application/json',
            ...(token && { 'Authorization': `Bearer ${token}` })
          };
        }

        async request(endpoint, options = {}) {
          const url = `${this.baseURL}${endpoint}`;
          const config = {
            headers: this.getAuthHeaders(),
            ...options
          };

          try {
            const response = await fetch(url, config);
            const data = await response.json();

            if (!response.ok) {
              throw new Error(data.message || 'Erro na requisição');
            }

            return data;
          } catch (error) {
            console.error('API Error:', error);
            throw error;
          }
        }

        // Auth
        async login(email, senha) {
          return this.request('/api/auth/login', {
            method: 'POST',
            body: JSON.stringify({ email, senha })
          });
        }

        async register(userData) {
          return this.request('/api/auth/register', {
            method: 'POST',
            body: JSON.stringify(userData)
          });
        }

        // Grupos
        async getGrupos() {
          return this.request('/api/grupos/publico');
        }

        // Doações
        async getDoacoes(filters = {}) {
          const params = new URLSearchParams(filters);
          return this.request(`/api/doacoes?${params}`);
        }

        async createDoacao(doacaoData) {
          return this.request('/api/doacoes', {
            method: 'POST',
            body: JSON.stringify(doacaoData)
          });
        }

        async updateDoacao(id, doacaoData) {
          return this.request(`/api/doacoes/${id}`, {
            method: 'PUT',
            body: JSON.stringify(doacaoData)
          });
        }

        async aprovarDoacao(id, observacoes = '') {
          return this.request(`/api/doacoes/${id}/aprovar`, {
            method: 'PUT',
            body: JSON.stringify({ observacoes })
          });
        }

        async rejeitarDoacao(id, motivo) {
          return this.request(`/api/doacoes/${id}/rejeitar`, {
            method: 'PUT',
            body: JSON.stringify({ motivo })
          });
        }

        // Upload
        async uploadFiles(files) {
          const formData = new FormData();
          files.forEach(file => {
            formData.append('files', file);
          });

          const token = localStorage.getItem('auth_token');
          return fetch(`${this.baseURL}/api/upload/donation-files`, {
            method: 'POST',
            headers: {
              ...(token && { 'Authorization': `Bearer ${token}` })
            },
            body: formData
          }).then(response => response.json());
        }
      }

      // Instância global da API
      const api = new ApiService();

      // Componente para proteger rotas autenticadas
      function ProtectedRoute({ children, user, requiredRole = null }) {
        const { navigate } = useRouter();
        
        useEffect(() => {
          if (!user) {
            navigate('/login');
            return;
          }
          
          if (requiredRole && user.role !== requiredRole) {
            navigate('/dashboard');
            return;
          }
        }, [user, requiredRole, navigate]);
        
        if (!user) return null;
        if (requiredRole && user.role !== requiredRole) return null;
        
        return children;
      }

      // Hook para gerenciar autenticação
      function useAuth() {
        const [user, setUser] = useState(null);
        const [loading, setLoading] = useState(true);
        const { navigate } = useRouter();
        
        useEffect(() => {
          // Verificar se há usuário salvo no localStorage
          const savedUser = lsGet(LS_KEYS.USER);
          const token = localStorage.getItem('auth_token');
          
          if (savedUser && token) {
            setUser(savedUser);
          }
          setLoading(false);
        }, []);
        
        const login = (userData) => {
          setUser(userData);
          lsSet(LS_KEYS.USER, userData);
          navigate('/dashboard');
        };
        
        const logout = () => {
          setUser(null);
          lsRemove(LS_KEYS.USER);
          localStorage.removeItem('auth_token');
          navigate('/login');
        };
        
        return { user, login, logout, loading };
      }

      function Header({ title, user, onLogout }) {
        const { navigate } = useRouter();
        
        return (
          <header>
            <span style={{ cursor: 'pointer' }} onClick={() => navigate('/dashboard')}>{title}</span>
            <div className="header-actions">
              {user && user.role === 'admin' && (
                <button className="btn btn-ghost" onClick={() => navigate('/admin')}>Admin</button>
              )}
              {user && <span style={{opacity:.95}}>{(user.role || 'USUÁRIO').toUpperCase()} - {user.name || 'Sessão'}</span>}
              {user && <button className="btn" onClick={onLogout}>Sair</button>}
            </div>
          </header>
        );
      }

      // === Storage simples para doações (simula fluxo original) ===
      const LS_KEYS = {
        DONATIONS: 'gl_donations',
        PENDING: 'gl_donations_pending',
        RECENT: 'gl_donations_recent',
        AUDIT: 'gl_donations_audit'
      };
      function lsGet(key, fallback=[]) { try { return JSON.parse(localStorage.getItem(key) || JSON.stringify(fallback)); } catch { return fallback; } }
      function lsSet(key, value) { localStorage.setItem(key, JSON.stringify(value)); }

      function hashString(str='') {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          hash = ((hash << 5) - hash) + str.charCodeAt(i);
          hash |= 0;
        }
        return Math.abs(hash);
      }

      // Configurações de validação de imagens
      const IMAGE_VALIDATION = {
        MAX_SIZE_MB: 5,
        MIN_WIDTH: 100,
        MIN_HEIGHT: 100,
        MAX_WIDTH: 4000,
        MAX_HEIGHT: 4000,
        ALLOWED_TYPES: ['image/jpeg', 'image/png', 'image/webp', 'application/pdf'],
        SIMILARITY_THRESHOLD: 0.9,
        MIN_OBJECT_CONFIDENCE: 0.7, // Confiança mínima para considerar um objeto detectado
        RECEIPT_KEYWORDS: [
          'nota', 'fiscal', 'comprovante', 'recibo', 'pagamento', 'valor', 'total',
          'cpf', 'cnpj', 'ie', 'rg', 'documento', 'venda', 'compra', 'cupom',
          'pagto', 'dinheiro', 'cartão', 'débito', 'crédito', 'pix', 'transferência'
        ],
        REQUIRED_OBJECTS: {
          'alimento': [
            'food', 'package', 'box', 'bottle', 'can', 'container', 'groceries', 
            'vegetable', 'fruit', 'rice', 'bean', 'pasta', 'oil', 'sugar', 'flour'
          ],
          'brinquedos': [
            'toy', 'doll', 'game', 'ball', 'car', 'bear', 'teddy', 'puzzle', 
            'lego', 'barbie', 'action figure', 'board game', 'card game'
          ],
          'fundos': [
            'money', 'bill', 'currency', 'receipt', 'document', 'banknote', 
            'check', 'payment', 'donation', 'deposit', 'transaction'
          ]
        },
        SUSPICIOUS_PATTERNS: {
          maxDonationsPerHour: 3,
          minTimeBetweenDonations: 5 * 60 * 1000, // 5 minutos
          similarDescriptionThreshold: 0.8,
          roundNumberMultipliers: [10, 50, 100], // Valores múltiplos considerados suspeitos
          unusualHours: { start: 0, end: 6 }, // 00:00 às 06:00
          minReceiptTextConfidence: 0.7,
          maxSimilarImages: 2 // Número máximo de imagens similares permitidas
        }
      };

      // Simula um serviço de reconhecimento de objetos (em produção, use uma API como Google Cloud Vision ou AWS Rekognition)
      async function detectObjectsInImage(imageData, category = null) {
        // Esta é uma simulação - em produção, substitua por chamada à API real
        return new Promise((resolve) => {
          setTimeout(async () => {
            // Se for um PDF, retorna como documento
            if (typeof imageData === 'string' && imageData.includes('application/pdf')) {
              resolve([
                { name: 'document', score: 0.95 },
                { name: 'text', score: 0.9 },
                { name: 'paper', score: 0.9 }
              ]);
              return;
            }

            // Objetos comuns por categoria
            const categoryObjects = {
              'alimento': [
                { name: 'food', score: 0.85 + Math.random() * 0.14 },
                { name: 'package', score: 0.8 + Math.random() * 0.19 },
                { name: 'box', score: 0.75 + Math.random() * 0.24 },
                { name: 'bottle', score: 0.7 + Math.random() * 0.29 },
                { name: 'can', score: 0.65 + Math.random() * 0.34 },
                { name: 'container', score: 0.6 + Math.random() * 0.39 }
              ],
              'brinquedos': [
                { name: 'toy', score: 0.85 + Math.random() * 0.14 },
                { name: 'doll', score: 0.8 + Math.random() * 0.19 },
                { name: 'game', score: 0.75 + Math.random() * 0.24 },
                { name: 'ball', score: 0.7 + Math.random() * 0.29 },
                { name: 'car', score: 0.65 + Math.random() * 0.34 },
                { name: 'bear', score: 0.6 + Math.random() * 0.39 }
              ],
              'fundos': [
                { name: 'money', score: 0.85 + Math.random() * 0.14 },
                { name: 'bill', score: 0.8 + Math.random() * 0.19 },
                { name: 'receipt', score: 0.75 + Math.random() * 0.24 },
                { name: 'document', score: 0.7 + Math.random() * 0.29 },
                { name: 'paper', score: 0.65 + Math.random() * 0.34 },
                { name: 'text', score: 0.6 + Math.random() * 0.39 }
              ]
            };

            // Objetos gerais que podem aparecer em qualquer imagem
            const generalObjects = [
              { name: 'person', score: 0.7 + Math.random() * 0.29 },
              { name: 'hand', score: 0.6 + Math.random() * 0.39 },
              { name: 'table', score: 0.5 + Math.random() * 0.49 },
              { name: 'background', score: 0.4 + Math.random() * 0.59 }
            ];

            // Seleciona 2-4 objetos da categoria (se fornecida) e 1-2 objetos gerais
            const selectedObjects = [];
            
            // Adiciona objetos específicos da categoria
            if (category && categoryObjects[category]) {
              const categoryObj = [...categoryObjects[category]];
              const count = 2 + Math.floor(Math.random() * 3); // 2-4 objetos
              for (let i = 0; i < Math.min(count, categoryObj.length); i++) {
                const idx = Math.floor(Math.random() * categoryObj.length);
                selectedObjects.push(categoryObj.splice(idx, 1)[0]);
              }
            }
            
            // Adiciona alguns objetos gerais
            const generalCount = 1 + Math.floor(Math.random() * 2); // 1-2 objetos
            for (let i = 0; i < generalCount && generalObjects.length > 0; i++) {
              const idx = Math.floor(Math.random() * generalObjects.length);
              selectedObjects.push(generalObjects.splice(idx, 1)[0]);
            }

            // Adiciona texto em 30% das imagens (simulando OCR)
            if (Math.random() > 0.7) {
              selectedObjects.push({
                name: 'text',
                score: 0.8 + Math.random() * 0.19,
                content: 'Texto de exemplo em imagem ' + Math.random().toString(36).substring(2, 8).toUpperCase()
              });
            }

            resolve(selectedObjects);
          }, 300 + Math.random() * 700); // Tempo de resposta variável entre 300-1000ms
        });
      }

      // Valida se a imagem contém os objetos esperados para a categoria
      async function validateImageContent(imageData, category) {
        try {
          // Se não houver imagem, retorna como inválido
          if (!imageData) {
            return { 
              valid: false,
              noImage: true,
              error: 'Imagem do item é obrigatória',
              detected: [],
              required: IMAGE_VALIDATION.REQUIRED_OBJECTS[category] || [],
              missing: IMAGE_VALIDATION.REQUIRED_OBJECTS[category] || []
            };
          }
          
          const requiredObjects = IMAGE_VALIDATION.REQUIRED_OBJECTS[category] || [];
          
          // Se for um PDF, verifica se é um documento válido
          if (typeof imageData === 'string' && imageData.includes('application/pdf')) {
            return {
              valid: true,
              isDocument: true,
              detected: ['document', 'text'],
              required: ['document'],
              missing: []
            };
          }
          
          // Se não há objetos requeridos, retorna válido
          if (requiredObjects.length === 0) {
            return { 
              valid: true,
              detected: [],
              required: [],
              missing: []
            };
          }
          
          // Detecta objetos na imagem
          const detectedObjects = await detectObjectsInImage(imageData, category);
          const minConfidence = IMAGE_VALIDATION.MIN_OBJECT_CONFIDENCE;
          
          // Filtra objetos com confiança suficiente
          const validObjects = detectedObjects.filter(obj => obj.score >= minConfidence);
          const foundObjects = validObjects.map(obj => obj.name);
          
          // Verifica se há texto que indique ser uma nota fiscal
          const hasReceiptText = validObjects.some(obj => 
            obj.name === 'text' && 
            obj.content &&
            IMAGE_VALIDATION.RECEIPT_KEYWORDS.some(kw => 
              obj.content.toLowerCase().includes(kw.toLowerCase())
            )
          );
          
          // Se for uma nota fiscal, é válida para qualquer categoria
          if (hasReceiptText) {
            return {
              valid: true,
              isDocument: true,
              detected: [...new Set([...foundObjects, 'receipt', 'document', 'text'])],
              required: ['receipt'],
              missing: []
            };
          }
          
          // Verifica quais objetos requeridos estão presentes
          const missingObjects = [];
          for (const reqObj of requiredObjects) {
            const found = validObjects.some(obj => 
              obj.name.toLowerCase().includes(reqObj.toLowerCase()) ||
              (obj.content && obj.content.toLowerCase().includes(reqObj.toLowerCase()))
            );
            if (!found) {
              missingObjects.push(reqObj);
            }
          }
          
          return {
            valid: true, // Sempre retorna válido, mesmo sem os objetos esperados
            isDocument: validObjects.some(obj => ['document', 'receipt', 'paper', 'text'].includes(obj.name)),
            detected: foundObjects,
            required: requiredObjects,
            missing: missingObjects,
            allDetectedObjects: validObjects
          };
          
        } catch (error) {
          console.error('Erro ao validar conteúdo da imagem:', error);
          // Em caso de erro, retorna como válido para não bloquear o usuário
          return {
            valid: true,
            error: 'Erro ao processar imagem, mas a validação foi ignorada',
            detected: [],
            required: [],
            missing: []
          };
        }
      }

      // Valida se há um comprovante de nota fiscal ou recibo
      async function validateReceipt(images) {
        if (!images || !Array.isArray(images) || images.length === 0) {
          return { 
            hasReceipt: false, 
            reason: 'Nenhuma imagem fornecida',
            confidence: 0
          };
        }
        
        let bestMatch = { confidence: 0 };
        
        for (const [index, img] of images.entries()) {
          try {
            // Se for PDF, assume que é um documento
            if (typeof img === 'string' && img.includes('application/pdf')) {
              return { 
                hasReceipt: true,
                isPdf: true,
                foundIn: `Arquivo PDF ${index + 1}`,
                confidence: 0.95
              };
            }
            
            // Detecta objetos na imagem (incluindo texto)
            const objects = await detectObjectsInImage(img);
            
            // Verifica se há texto que indique ser uma nota fiscal
            const textObjects = objects.filter(o => o.name === 'text' && o.content);
            let receiptScore = 0;
            let matchedKeywords = [];
            
            if (textObjects.length > 0) {
              const textContent = textObjects.map(t => t.content).join(' ').toLowerCase();
              matchedKeywords = IMAGE_VALIDATION.RECEIPT_KEYWORDS.filter(kw => 
                textContent.includes(kw.toLowerCase())
              );
              receiptScore = Math.min(1, matchedKeywords.length / 5); // Pontua baseado em quantas palavras-chave foram encontradas
            }
            
            // Verifica se há objetos de documento com alta confiança
            const documentObjects = objects.filter(o => 
              ['document', 'receipt', 'paper'].includes(o.name) && 
              o.score >= IMAGE_VALIDATION.MIN_OBJECT_CONFIDENCE
            );
            
            // Combina as pontuações
            const documentScore = documentObjects.length > 0 
              ? Math.max(...documentObjects.map(o => o.score)) 
              : 0;
              
            const totalScore = Math.max(documentScore, receiptScore);
            
            // Atualiza o melhor resultado encontrado
            if (totalScore > bestMatch.confidence) {
              bestMatch = {
                hasReceipt: totalScore >= IMAGE_VALIDATION.SUSPICIOUS_PATTERNS.minReceiptTextConfidence,
                confidence: totalScore,
                foundIn: `Imagem ${index + 1}`,
                matchedKeywords,
                documentObjects: documentObjects.map(o => o.name)
              };
            }
            
            // Se a confiança for muito alta, retorna imediatamente
            if (totalScore >= 0.9) {
              return bestMatch;
            }
            
          } catch (error) {
            console.error(`Erro ao processar imagem ${index + 1}:`, error);
            // Continua para a próxima imagem em caso de erro
          }
        }
        
        // Retorna o melhor resultado encontrado (pode ser falso se nenhum documento for encontrado)
        if (bestMatch.confidence > 0) {
          return bestMatch;
        }
        
        return { 
          hasReceipt: false, 
          reason: 'Nenhum documento ou nota fiscal identificada',
          confidence: 0,
          requiredKeywords: IMAGE_VALIDATION.RECEIPT_KEYWORDS.slice(0, 5) + '...' // Mostra apenas as primeiras 5 palavras-chave
        };
      }

      // Verifica padrões suspeitos nas doações
      function checkSuspiciousPatterns(newDonation, userDonations) {
        try {
          if (!newDonation) return { isSuspicious: false };
          
          const patterns = IMAGE_VALIDATION.SUSPICIOUS_PATTERNS;
          const now = Date.now();
          const recentDonations = userDonations.filter(d => {
            if (!d.createdAt && !d.updatedAt) return false;
            const donationTime = new Date(d.createdAt || d.updatedAt || now).getTime();
            return (now - donationTime) < 24 * 60 * 60 * 1000; // Últimas 24h
          });
          
          // Padrão 1: Muitas doações em pouco tempo
          if (recentDonations.length >= patterns.maxDonationsPerHour) {
            return {
              isSuspicious: true,
              reason: `Muitas doações (${recentDonations.length + 1}) em um curto período`,
              score: 0.8,
              pattern: 'high_frequency',
              details: {
                count: recentDonations.length + 1,
                period: '1h',
                limit: patterns.maxDonationsPerHour
              }
            };
          }
          
          // Padrão 2: Descrições muito similares
          if (newDonation.description && userDonations.length > 0) {
            const similarDescriptions = userDonations.filter(d => 
              d.description &&
              calculateSimilarity(d.description, newDonation.description) > patterns.similarDescriptionThreshold
            );
            
            if (similarDescriptions.length > 0) {
              return {
                isSuspicious: true,
                reason: 'Descrição muito similar a doações anteriores',
                score: 0.7,
                pattern: 'similar_description',
                details: {
                  similarCount: similarDescriptions.length,
                  example: similarDescriptions[0].description.substring(0, 50) + '...',
                  similarity: calculateSimilarity(similarDescriptions[0].description, newDonation.description).toFixed(2)
                }
              };
            }
          }
          
          // Padrão 3: Valores arredondados ou muito altos
          if (newDonation.amount) {
            const amount = parseFloat(newDonation.amount);
            if (!isNaN(amount)) {
              // Verifica se é um valor redondo (múltiplo de 10, 50, 100)
              const isRoundNumber = (num, base) => Math.abs(Math.round(num / base) * base - num) < 0.01;
              
              // Verifica múltiplos suspeitos
              for (const multiple of patterns.roundNumberMultipliers || []) {
                if (isRoundNumber(amount, multiple) && amount >= multiple) {
                  return {
                    isSuspicious: true,
                    reason: `Valor arredondado (múltiplo de ${multiple}) pode indicar fraude`,
                    score: 0.5 + (0.3 * (multiple === 100 ? 1 : multiple === 50 ? 0.7 : 0.4)),
                    pattern: 'round_number',
                    details: {
                      amount: amount,
                      multiple: multiple
                    }
                  };
                }
              }
              
              // Verifica valores muito altos para a categoria
              const categoryLimits = {
                alimento: 1000,   // 1000kg de alimento
                brinquedos: 500,  // 500 brinquedos
                fundos: 10000     // R$ 10.000,00
              };
              
              const limit = categoryLimits[newDonation.category] || 1000;
              if (amount > limit) {
                return {
                  isSuspicious: true,
                  reason: `Valor muito alto para a categoria ${newDonation.category}`,
                  score: 0.8,
                  pattern: 'high_value',
                  details: {
                    amount: amount,
                    category: newDonation.category,
                    limit: limit
                  }
                };
              }
            }
          }
          
          // Padrão 4: Horário incomum (entre meia-noite e 6h)
          const hour = new Date().getHours();
          if (hour >= patterns.unusualHours.start && hour < patterns.unusualHours.end) {
            return {
              isSuspicious: true,
              reason: 'Atividade em horário incomum (madrugada)',
              score: 0.4,
              pattern: 'unusual_time',
              details: {
                hour: hour,
                timeRange: `${patterns.unusualHours.start}:00-${patterns.unusualHours.end}:00`
              }
            };
          }
          
          // Padrão 5: Muitas doações com o mesmo valor
          if (newDonation.amount && userDonations.length > 2) {
            const sameAmount = userDonations.filter(d => {
              if (!d.amount) return false;
              const donationAmount = parseFloat(d.amount);
              const newAmount = parseFloat(newDonation.amount);
              return !isNaN(donationAmount) && !isNaN(newAmount) && 
                     Math.abs(donationAmount - newAmount) < 0.01;
            });
            
            if (sameAmount.length >= 2) {
              return {
                isSuspicious: true,
                reason: `Múltiplas doações com o mesmo valor (${newDonation.amount})`,
                score: 0.6,
                pattern: 'same_amount',
                details: {
                  amount: newDonation.amount,
                  count: sameAmount.length + 1
                }
              };
            }
          }
          
          return { 
            isSuspicious: false,
            details: {
              checkedAt: new Date().toISOString(),
              patternsChecked: ['frequency', 'similarity', 'round_numbers', 'high_value', 'unusual_time', 'same_amount']
            }
          };
          
        } catch (error) {
          console.error('Erro ao verificar padrões suspeitos:', error);
          // Em caso de erro, retorna como não suspeito para não bloquear o usuário
          return { 
            isSuspicious: false,
            error: 'Erro na verificação de padrões',
            details: { error: error.message }
          };
        }
      }

      // Função para calcular similaridade entre duas imagens (0 a 1)
      // Calcula similaridade entre duas strings (0 a 1)
      function calculateSimilarity(str1, str2) {
        if (!str1 || !str2) return 0;
        if (str1 === str2) return 1.0;
        
        // Remove caracteres especiais e converte para minúsculas
        const cleanStr1 = str1.toLowerCase().replace(/[^a-z0-9\s]/g, '');
        const cleanStr2 = str2.toLowerCase().replace(/[^a-z0-9\s]/g, '');
        
        // Se uma string estiver contida na outra, retorna alta similaridade
        if (cleanStr1.includes(cleanStr2) || cleanStr2.includes(cleanStr1)) {
          return 0.9;
        }
        
        // Algoritmo de similaridade de Jaccard
        const set1 = new Set(cleanStr1.split(/\s+/));
        const set2 = new Set(cleanStr2.split(/\s+/));
        
        const intersection = new Set([...set1].filter(x => set2.has(x)));
        const union = new Set([...set1, ...set2]);
        
        return union.size > 0 ? intersection.size / union.size : 0;
      }

      function calculateImageSimilarity(img1, img2) {
        // Implementação simplificada de similaridade
        // Em produção, considere usar uma biblioteca como 'sharp' ou 'jimp' no backend
        const str1 = typeof img1 === 'string' ? img1 : (img1.dataUrl || '');
        const str2 = typeof img2 === 'string' ? img2 : (img2.dataUrl || '');
        
        if (!str1 || !str2) return 0;
        if (str1 === str2) return 1.0;
        
        // Comparação simples baseada em hash
        const len = Math.min(str1.length, str2.length, 1000);
        let match = 0;
        for (let i = 0; i < len; i++) {
          if (str1[i] === str2[i]) match++;
        }
        return match / len;
      }

      function buildAuditEvent(donation, action, actor, extra={}) {
        return {
          donationId: donation.id,
          action,
          actor,
          timestamp: new Date().toISOString(),
          extra
        };
      }

      // Valida se uma imagem atende aos requisitos
      async function validateImage(file) {
        // Valida tipo
        if (!IMAGE_VALIDATION.ALLOWED_TYPES.includes(file.type)) {
          throw new Error(`Tipo de arquivo não suportado. Use: ${IMAGE_VALIDATION.ALLOWED_TYPES.join(', ')}`);
        }
        
        // Valida tamanho
        if (file.size > IMAGE_VALIDATION.MAX_SIZE_MB * 1024 * 1024) {
          throw new Error(`Tamanho máximo permitido: ${IMAGE_VALIDATION.MAX_SIZE_MB}MB`);
        }
        
        // Valida dimensões
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            if (img.width < IMAGE_VALIDATION.MIN_WIDTH || img.height < IMAGE_VALIDATION.MIN_HEIGHT) {
              reject(`Dimensões mínimas: ${IMAGE_VALIDATION.MIN_WIDTH}x${IMAGE_VALIDATION.MIN_HEIGHT}px`);
            } else if (img.width > IMAGE_VALIDATION.MAX_WIDTH || img.height > IMAGE_VALIDATION.MAX_HEIGHT) {
              reject(`Dimensões máximas: ${IMAGE_VALIDATION.MAX_WIDTH}x${IMAGE_VALIDATION.MAX_HEIGHT}px`);
            } else {
              resolve(true);
            }
          };
          img.onerror = () => reject('Erro ao carregar imagem');
          img.src = URL.createObjectURL(file);
        });
      }

      // Gera fingerprints para detecção de duplicatas
      function fingerprintsFromPhotos(photos=[]) {
        return photos.map((p, i) => {
          const str = typeof p === 'string' ? p : (p.dataUrl || '');
          // Usa uma amostra maior para melhor precisão
          const sample = str.length > 2000 ? 
            str.substring(0, 1000) + str.substring(Math.floor(str.length/2) - 500, Math.floor(str.length/2) + 500) + str.slice(-1000) :
            str;
          return hashString(sample + str.length);
        });
      }

      function pushAuditEvents(events=[]) {
        if (!events.length) return;
        if (events.length === 1 && events[0] == null) return;
        const list = lsGet(LS_KEYS.AUDIT, []);
        events.filter(Boolean).forEach(ev => list.unshift(ev));
        if (list.length > 200) list.splice(200);
        lsSet(LS_KEYS.AUDIT, list);
      }

      function listAuditTrail(limit=50) {
        try {
          const trail = lsGet(LS_KEYS.AUDIT, []);
          return trail.slice(0, limit);
        } catch (error) {
          console.error('Erro ao carregar histórico de auditoria:', error);
          return [];
        }
      }


      function computeRiskScore({ donation, userHistory=[] }) {
        let score = 0;
        const amount = donation.amount || 0;
        if (donation.category === 'fundos' && amount > 500) score += 6;
        else if (donation.category === 'fundos' && amount > 200) score += 4;
        if (donation.category !== 'fundos' && amount > 40) score += 2;
        const now = Date.now();
        const created = new Date(donation.createdAt || Date.now()).getTime();
        if (now - created < 5 * 60 * 1000) score += 1; // envio muito rápido
        if (!donation.photos || donation.photos.length < 2) score += 2;
        const duplicates = fingerprintsFromPhotos(donation.photos);
        const dupCount = userHistory.reduce((acc, prev) => {
          const prevPrints = prev.fingerprints || [];
          if (prev.id === donation.id) return acc;
          const intersection = prevPrints.filter(p => duplicates.includes(p));
          return intersection.length ? acc + 1 : acc;
        }, 0);
        score += dupCount * 5;
        return score;
      }

      function mapRisk(score=0) {
        if (score >= 10) return { level: 'Alto', className: 'risk-high' };
        if (score >= 5) return { level: 'Médio', className: 'risk-medium' };
        return { level: 'Baixo', className: 'risk-low' };
      }

      function normalizeDonationList(list=[]) {
        const cloned = list.map(d => ({ ...d }));
        const byUser = {};
        cloned.forEach(d => {
          if (!Array.isArray(d.photos)) d.photos = [];
          if (!Array.isArray(d.fingerprints) || d.fingerprints.length === 0) {
            d.fingerprints = fingerprintsFromPhotos(d.photos);
          }
          const key = d.user?.name || '__';
          byUser[key] = byUser[key] || [];
          byUser[key].push(d);
        });
        Object.values(byUser).forEach(items => {
          items.sort((a,b)=> new Date(a.createdAt || a.updatedAt || 0) - new Date(b.createdAt || b.updatedAt || 0));
          items.forEach((d, idx) => {
            const history = items.filter((_, j) => j !== idx);
            const score = computeRiskScore({ donation: d, userHistory: history });
            const { level, className } = mapRisk(score);
            d.riskScore = score;
            d.riskLevel = level;
            d.riskClass = className;
            if (d.status === 'Pendente') {
              d.needsEvidence = d.needsEvidence || level === 'Alto';
            } else {
              d.needsEvidence = false;
            }
          });
        });
        return cloned;
      }

      function syncDonationCaches() {
        const normalized = normalizeDonationList(lsGet(LS_KEYS.DONATIONS, []));
        lsSet(LS_KEYS.DONATIONS, normalized);
        const byId = Object.fromEntries(normalized.map(d => [d.id, d]));
        const pendingRaw = lsGet(LS_KEYS.PENDING, []).map(d => ({ ...byId[d.id], ...d }));
        lsSet(LS_KEYS.PENDING, pendingRaw);
        const recentRaw = lsGet(LS_KEYS.RECENT, []).map(d => ({ ...byId[d.id], ...d }));
        lsSet(LS_KEYS.RECENT, recentRaw);
        return {
          normalized,
          pending: pendingRaw,
          recent: recentRaw
        };
      }

      async function createDonation({ description, amount, category, unit, team, user, photos=[] }) {
        try {
          // Validação inicial
          if (!description || !amount || !category || !team || !user) {
            throw new Error('Dados incompletos para criar a doação');
          }

          const all = lsGet(LS_KEYS.DONATIONS, []);
          const userDonations = all.filter(d => d.user?.name === user.name);
          
          // Verifica padrões suspeitos
          const patternCheck = checkSuspiciousPatterns(
            { description, amount, category, team },
            userDonations
          );

          // Valida conteúdo das imagens
          let imageValidations = [];
          for (const photo of photos) {
            const validation = await validateImageContent(photo, category);
            if (!validation.valid) {
              imageValidations.push({
                photo: photo.substring(0, 50) + '...',
                missing: validation.missing
              });
            }
          }

          // Valida nota fiscal (pelo menos uma imagem deve ser um documento)
          const receiptValidation = await validateReceipt(photos);
          
          // Calcula pontuação de risco inicial
          let riskScore = 0;
          const riskFactors = [];
          
          if (patternCheck.isSuspicious) {
            riskScore += patternCheck.score * 50; // Até 50 pontos por padrão suspeito
            riskFactors.push(`Padrão suspeito: ${patternCheck.reason} (${Math.round(patternCheck.score * 100)}%)`);
          }
          
          if (imageValidations.length > 0) {
            riskScore += 30; // 30 pontos por imagem inválida
            riskFactors.push(`Imagens não correspondem à categoria (faltando: ${imageValidations[0].missing.join(', ')})`);
          }
          
          if (!receiptValidation.hasReceipt) {
            riskScore += 40; // 40 pontos por falta de nota fiscal
            riskFactors.push('Nota fiscal não identificada');
          }
          
          // Cria a doação com as validações
          const id = (all.reduce((m, d) => Math.max(m, d.id || 0), 0) + 1) || 1;
          const donation = {
            id,
            description,
            amount: parseFloat(amount || 0),
            category,
            unit,
            team: team || '',
            user,
            photos,
            fingerprints: fingerprintsFromPhotos(photos),
            status: 'Pendente',
            createdAt: new Date().toISOString(),
            riskScore,
            riskLevel: riskScore >= 70 ? 'Alto' : riskScore >= 40 ? 'Médio' : 'Baixo',
            validations: {
              patternCheck,
              imageValidations,
              receiptValidation,
              riskFactors
            },
            needsEvidence: riskScore >= 40
          };
          
          // Salva a doação
          all.push(donation);
          lsSet(LS_KEYS.DONATIONS, all);
          
          // Adiciona à lista de pendentes se não for de alto risco
          if (donation.riskLevel !== 'Alto') {
            const pend = lsGet(LS_KEYS.PENDING, []);
            pend.push(donation);
            lsSet(LS_KEYS.PENDING, pend);
          }
          
          // Registra o evento de auditoria
          pushAuditEvents([
            buildAuditEvent(
              donation, 
              'Registrada', 
              user?.name || 'Aluno', 
              { 
                description,
                riskScore,
                riskLevel: donation.riskLevel,
                needsEvidence: donation.needsEvidence
              }
            )
          ]);
          
          syncDonationCaches();
          return donation;
          
        } catch (error) {
          console.error('Erro ao criar doação:', error);
          throw error;
        }
      }
      function listPending() { return syncDonationCaches().pending; }
      function listRecent() { return syncDonationCaches().recent; }
      function listAllDonations() { return syncDonationCaches().normalized; }
      function listUserDonations(user) { const all = listAllDonations(); return all.filter(d => d.user?.name === user.name); }
      function updateDonationStatus(id, status, motivo=null) {
        const all = lsGet(LS_KEYS.DONATIONS, []);
        const idx = all.findIndex(d=>d.id===id);
        if (idx>=0) {
          all[idx].status = status; all[idx].motivo = motivo; all[idx].updatedAt = new Date().toISOString();
          if (status === 'Aprovada') {
            all[idx].needsEvidence = false;
            all[idx].riskScore = Math.min(all[idx].riskScore || 0, 2);
            all[idx].riskLevel = 'Baixo';
            all[idx].riskClass = 'risk-low';
          }
          lsSet(LS_KEYS.DONATIONS, all);
          const pend = lsGet(LS_KEYS.PENDING, []).filter(d=>d.id!==id); lsSet(LS_KEYS.PENDING, pend);
          if (status === 'Aprovada') {
            const rec = lsGet(LS_KEYS.RECENT, []); rec.unshift(all[idx]); if (rec.length>50) rec.splice(50); lsSet(LS_KEYS.RECENT, rec);
          }
          pushAuditEvents([buildAuditEvent(all[idx], status === 'Aprovada' ? 'Aprovada' : 'Rejeitada', 'Mentor/Admin', { motivo })]);
          const { normalized } = syncDonationCaches();
          return normalized.find(d => d.id === id) || all[idx];
        }
        return null;
      }

      function flagDonationForEvidence(id, actor, reason='') {
        const all = lsGet(LS_KEYS.DONATIONS); const idx = all.findIndex(d=>d.id===id);
        if (idx >= 0) {
          all[idx].needsEvidence = true;
          all[idx].riskScore = Math.max(all[idx].riskScore || 0, 10);
          all[idx].riskLevel = 'Alto';
          all[idx].riskClass = 'risk-high';
          lsSet(LS_KEYS.DONATIONS, all);
          const pend = lsGet(LS_KEYS.PENDING).map(d => d.id === id ? { ...d, needsEvidence: true, riskLevel: 'Alto', riskClass: 'risk-high' } : d);
          lsSet(LS_KEYS.PENDING, pend);
          pushAuditEvents([buildAuditEvent(all[idx], 'Solicitada Evidência', actor || 'Mentor/Admin', { reason })]);
          syncDonationCaches();
          return true;
        }
        return false;
      }

      function appendEvidenceToDonation(id, photos=[], actor='Participante') {
        const newPhotos = Array.from(photos || []);
        if (!newPhotos.length) return null;
        const all = lsGet(LS_KEYS.DONATIONS); const idx = all.findIndex(d=>d.id===id);
        if (idx >= 0) {
          const donation = all[idx];
          const existingPrints = donation.fingerprints || [];
          const incoming = fingerprintsFromPhotos(newPhotos);
          const filtered = newPhotos.filter((src, i) => !existingPrints.includes(incoming[i]));
          const filteredPrints = incoming.filter((hash) => !existingPrints.includes(hash));
          if (!filtered.length) {
            return donation;
          }
          donation.photos = [...(donation.photos || []), ...filtered];
          donation.fingerprints = [...existingPrints, ...filteredPrints];
          donation.updatedAt = new Date().toISOString();
          donation.needsEvidence = false;
          lsSet(LS_KEYS.DONATIONS, all);
          const pend = lsGet(LS_KEYS.PENDING).map(d => d.id === id ? { ...d, photos: donation.photos, fingerprints: donation.fingerprints, needsEvidence: false } : d);
          lsSet(LS_KEYS.PENDING, pend);
          pushAuditEvents([buildAuditEvent(donation, 'Evidência Anexada', actor || 'Participante', { quantidade: filtered.length })]);
          const { normalized } = syncDonationCaches();
          return normalized.find(d => d.id === id) || donation;
        }
        return null;
      }

      // === Student: registro de doações ===
      function StudentDonationsSection({ user }) {
        const [form, setForm] = useState({ 
          description: '', 
          amount: '', 
          category: 'alimento', 
          team: '', 
          photos: [], 
          previews: [],
          validations: []
        });
        const [error, setError] = useState('');
        const [success, setSuccess] = useState('');
        const [mine, setMine] = useState([]);
        const [uploading, setUploading] = useState(false);
        const [validationResults, setValidationResults] = useState(null);

        const unitFor = (cat) => (cat==='alimento' ? 'kg' : cat==='fundos' ? 'R$' : 'un');
        const placeholderFor = (cat) => (cat==='alimento' ? 'Valor (kg)' : cat==='fundos' ? 'Valor (R$)' : 'Quantidade (un)');

        const readFilesAsDataUrls = async (fileList) => {
          const files = Array.from(fileList || []).slice(0, 6);
          const readers = files.map(f => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(f);
          }));
          return Promise.all(readers);
        };

        const onPhotosChange = async (e) => {
          try {
            const files = Array.from(e.target.files || []).slice(0, 6);
            
            if (files.length === 0) return;
            
            setUploading(true);
            setError('');
            
            // Upload real via API
            const uploadResult = await api.uploadFiles(files);
            
            if (uploadResult.success) {
              const uploadedFiles = uploadResult.data.files;
              
              setForm(f => ({ 
                ...f, 
                photos: [...f.photos, ...uploadedFiles].slice(0, 6),
                previews: [...f.previews, ...uploadedFiles.map(file => file.url)].slice(0, 6)
              }));
              
              console.log('✅ Upload realizado com sucesso:', uploadedFiles);
            } else {
              throw new Error(uploadResult.message || 'Erro no upload');
            }
            
          } catch (err) {
            console.error('Erro ao fazer upload:', err);
            setError(err.message || 'Erro ao fazer upload dos arquivos');
            e.target.value = '';
          } finally {
            setUploading(false);
          }
        };

        const loadMine = () => setMine(listUserDonations(user));
        useEffect(()=>{ loadMine(); }, [user?.name]);
        // Define a equipe do usuário automaticamente
        useEffect(() => {
          if (user && user.team) {
            setForm(f => ({ ...f, team: user.team }));
          }
        }, [user]);

        const submit = async (e) => {
          e.preventDefault();
          setError('');
          setSuccess('');
          setValidationResults(null);
          
          try {
            // Validações básicas
            if (!form.description || !form.amount) {
              throw new Error('Preencha todos os campos obrigatórios');
            }
            
            // Garantir que a equipe está definida
            if (!form.team && user?.team) {
              setForm(f => ({ ...f, team: user.team }));
            }
            
            if (!form.team) {
              throw new Error('Usuário não possui equipe definida. Contate o administrador.');
            }
            
            // Verifica se há pelo menos uma foto (imagem do item) e um comprovante
            if (!form.photos || form.photos.length === 0) {
              throw new Error('É obrigatório enviar pelo menos uma foto do item e um comprovante');
            }
            
            const amount = parseFloat(form.amount);
            if (isNaN(amount) || amount <= 0) {
              throw new Error('Valor inválido');
            }
            
            // Valida se há pelo menos uma imagem do item e um comprovante
            const hasItemImage = form.photos.some(photo => 
              !photo.includes('application/pdf') && 
              !photo.includes('data:application/pdf')
            );
            
            const hasReceipt = form.photos.some(photo => 
              photo.includes('application/pdf') || 
              photo.includes('data:application/pdf')
            );
            
            if (!hasItemImage) {
              throw new Error('É obrigatório enviar pelo menos uma foto do item');
            }
            
            if (!hasReceipt) {
              throw new Error('É obrigatório enviar um comprovante (nota fiscal, recibo, etc.)');
            }
            
            const unit = unitFor(form.category);
            
            // Validação de conteúdo das imagens
            const validations = [];
            
            // 1. Valida reconhecimento de objetos
            const objectValidations = [];
            for (const photo of form.photos) {
              const validation = await validateImageContent(photo, form.category);
              objectValidations.push(validation);
              
              if (!validation.valid) {
                validations.push({
                  type: 'warning',
                  message: `Imagem não parece conter ${form.category}. ` +
                           `Esperado: ${validation.required.join(', ')}. ` +
                           `Encontrado: ${validation.detected.join(', ') || 'nada relevante'}`
                });
              }
            }
            
            // 2. Valida nota fiscal
            const receiptCheck = await validateReceipt(form.photos);
            if (!receiptCheck.hasReceipt) {
              validations.push({
                type: 'warning',
                message: 'Nenhuma nota fiscal ou comprovante foi identificado nas imagens.'
              });
            }
            
            // 3. Verifica padrões suspeitos
            const userDonations = listUserDonations(user);
            const patternCheck = checkSuspiciousPatterns(
              { description: form.description, amount, category: form.category, team: form.team },
              userDonations
            );
            
            if (patternCheck.isSuspicious) {
              validations.push({
                type: 'alert',
                message: `Possível atividade suspeita detectada: ${patternCheck.reason}`
              });
            }
            
            // Se houver validações de alerta, exibe para o usuário confirmar
            if (validations.some(v => v.type === 'alert')) {
              setValidationResults({
                validations,
                formData: { ...form, amount, unit },
                onConfirm: async () => {
                  try {
                    setUploading(true);
                    const donation = await createDonation({
                      ...form,
                      amount,
                      unit,
                      user: { 
                        id: user.name, 
                        name: user.name, 
                        role: user.role 
                      }
                    });
                    
                    // Limpa o formulário
                    setForm({ 
                      description: '', 
                      amount: '', 
                      category: form.category, 
                      team: form.team, 
                      photos: [], 
                      previews: [] 
                    });
                    
                    setSuccess('Doação registrada com sucesso! ' + 
                      (donation.riskLevel === 'Alto' ? 
                        'Sua doação será analisada pela equipe.' : 
                        'Aguardando aprovação.')
                    );
                    
                    loadMine();
                    
                  } catch (err) {
                    console.error('Erro ao confirmar doação:', err);
                    setError('Erro ao registrar doação: ' + (err.message || 'Tente novamente.'));
                  } finally {
                    setUploading(false);
                    setValidationResults(null);
                  }
                },
                onCancel: () => setValidationResults(null)
              });
              return;
            }
            
            // Se não houver alertas, cria a doação diretamente
            setUploading(true);
            const doacaoData = {
              descricao: form.description,
              quantidade: amount,
              categoria: form.category,
              fotos: form.photos
            };
            
            const result = await api.createDoacao(doacaoData);
            
            // Limpa o formulário
            setForm({ 
              description: '', 
              amount: '', 
              category: form.category, 
              team: form.team, 
              photos: [], 
              previews: [] 
            });
            
            setSuccess('Doação registrada com sucesso! Aguardando aprovação do mentor.');
            
            // Recarregar lista de doações
            loadMine();
            
          } catch (err) {
            console.error('Erro ao registrar doação:', err);
            setError(err.message || 'Ocorreu um erro ao registrar a doação. Tente novamente.');
          } finally {
            setUploading(false);
          }  
        };

        const addEvidence = async (donationId, files) => {
          if (!files || files.length === 0) return;
          try {
            setUploading(true); setError('');
            const dataUrls = await readFilesAsDataUrls(files);
            const updated = appendEvidenceToDonation(donationId, dataUrls, user?.name || 'Participante');
            if (updated) {
              setSuccess('Evidências adicionais anexadas com sucesso!');
              loadMine();
            }
          } catch (e) {
            setError('Não foi possível anexar as evidências. Tente novamente.');
          } finally {
            setUploading(false);
          }
        };

        // Componente para exibir a confirmação de validação
        const ValidationConfirmation = ({ results, onConfirm, onCancel }) => (
          <div className="validation-modal" style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: 'rgba(0,0,0,0.7)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: '20px'
          }}>
            <div style={{
              background: 'white',
              borderRadius: '12px',
              padding: '24px',
              maxWidth: '500px',
              width: '100%',
              maxHeight: '90vh',
              overflowY: 'auto'
            }}>
              <h3 style={{ marginTop: 0, color: '#333' }}>Confirmação Necessária</h3>
              <p>Foram identificados os seguintes itens que requerem sua atenção:</p>
              
              <div style={{ margin: '16px 0' }}>
                {results.validations.map((v, i) => (
                  <div key={i} style={{
                    padding: '12px',
                    margin: '8px 0',
                    borderRadius: '6px',
                    backgroundColor: v.type === 'alert' ? '#fff3cd' : '#e2f4ff',
                    borderLeft: `4px solid ${v.type === 'alert' ? '#ffc107' : '#0d6efd'}`,
                    color: '#333'
                  }}>
                    {v.message}
                  </div>
                ))}
              </div>
              
              <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '12px', marginTop: '24px' }}>
                <button 
                  type="button" 
                  onClick={onCancel}
                  style={{
                    padding: '10px 20px',
                    borderRadius: '6px',
                    border: '1px solid #ddd',
                    background: 'white',
                    cursor: 'pointer'
                  }}
                >
                  Revisar
                </button>
                <button 
                  type="button" 
                  onClick={onConfirm}
                  style={{
                    padding: '10px 20px',
                    borderRadius: '6px',
                    border: 'none',
                    background: '#0d6efd',
                    color: 'white',
                    cursor: 'pointer'
                  }}
                >
                  Confirmar Envio
                </button>
              </div>
            </div>
          </div>
        );

        return (
          <div className="container" style={{ paddingTop: 16 }}>
            {validationResults && (
              <ValidationConfirmation 
                results={validationResults}
                onConfirm={validationResults.onConfirm}
                onCancel={validationResults.onCancel}
              />
            )}
            
            <div className="grid-2">
              <Card title="Registrar Doação">
                <form onSubmit={submit} style={{ display:'grid', gap:12 }} className="anim-fade">
                  <input className="input" placeholder="Descrição" value={form.description} onChange={(e)=>setForm(f=>({...f, description:e.target.value}))} />
                  <select className="input" value={form.category} onChange={(e)=>setForm(f=>({...f, category:e.target.value}))}>
                    <option value="alimento">Doações de alimento (kg)</option>
                    <option value="fundos">Arrecadações de fundos (R$)</option>
                    <option value="brinquedos">Brinquedos (un)</option>
                  </select>
                  <div style={{ padding: '10px', backgroundColor: 'rgba(77, 242, 194, 0.1)', borderRadius: '8px', border: '1px solid rgba(77, 242, 194, 0.3)' }}>
                    <div style={{ fontSize: '0.9rem', color: '#4df2c2', fontWeight: '600' }}>
                      🏢 Sua Equipe: {user?.team || 'Não definida'}
                    </div>
                    <div style={{ fontSize: '0.8rem', color: 'rgba(77, 242, 194, 0.8)', marginTop: '4px' }}>
                      As doações serão automaticamente atribuídas à sua equipe
                    </div>
                  </div>
                  <input className="input" placeholder={placeholderFor(form.category)} value={form.amount} onChange={(e)=>setForm(f=>({...f, amount:e.target.value}))} />
                  <div style={{ display:'grid', gap:8 }}>
                    <input 
                      className="input" 
                      type="file" 
                      accept="image/*,.pdf" 
                      multiple 
                      onChange={onPhotosChange} 
                      disabled={uploading}
                    />
                    <div style={{ color:'#6c757d', fontSize:12 }}>
                      Envie ao menos 2 fotos: item, contexto e nota fiscal (máx. 6 arquivos)
                      <br/>Formatos aceitos: JPG, PNG, PDF
                    </div>
                    {form.previews && form.previews.length > 0 && (
                      <div style={{ display:'flex', gap:8, flexWrap:'wrap' }}>
                        {form.previews.map((src, idx) => (
                          <img key={idx} src={src} alt={`Foto ${idx+1}`} style={{ width:72, height:72, objectFit:'cover', borderRadius:8, border:'1px solid #e9ecef' }} />
                        ))}
                      </div>
                    )}
                  </div>
                  <div style={{ display:'flex', flexDirection: 'column', gap: '12px' }}>
                    <div style={{ display:'flex', gap:12, alignItems:'center' }}>
                      <button 
                        className="btn" 
                        type="submit" 
                        disabled={uploading || form.photos.length < 2}
                      >
                        {uploading ? 'Processando...' : 'Cadastrar Doação'}
                      </button>
                      {uploading && (
                        <div className="spinner-border text-primary" role="status">
                          <span className="visually-hidden">Carregando...</span>
                        </div>
                      )}
                    </div>
                    
                    {form.photos.length > 0 && (
                      <div style={{ 
                        padding: '12px',
                        borderRadius: '6px',
                        backgroundColor: form.photos.length >= 2 ? '#e8f5e9' : '#fff3e0',
                        borderLeft: `4px solid ${form.photos.length >= 2 ? '#4caf50' : '#ff9800'}`
                      }}>
                        <div style={{ fontWeight: '500', marginBottom: '4px' }}>
                          {form.photos.length >= 2 ? '✓ Pronto para enviar' : 'Atenção'}
                        </div>
                        <div style={{ fontSize: '13px', color: '#333' }}>
                          {form.photos.length} {form.photos.length === 1 ? 'arquivo' : 'arquivos'} anexados
                          {form.photos.length < 2 && ' (mínimo 2 necessários)'}
                        </div>
                      </div>
                    )}
                    
                    {error && (
                      <div style={{
                        padding: '12px',
                        borderRadius: '6px',
                        backgroundColor: '#ffebee',
                        borderLeft: '4px solid #f44336',
                        color: '#d32f2f',
                        marginTop: '8px'
                      }}>
                        {error}
                      </div>
                    )}
                    
                    {success && (
                      <div style={{
                        padding: '12px',
                        borderRadius: '6px',
                        backgroundColor: '#e8f5e9',
                        borderLeft: '4px solid #4caf50',
                        color: '#2e7d32',
                        marginTop: '8px'
                      }}>
                        {success}
                      </div>
                    )}
                  </div>
                </form>
              </Card>
              <Card title="Minhas Doações">
                <div style={{ overflowX:'auto' }}>
                  <table style={{ width:'100%', borderCollapse:'collapse' }}>
                    <thead>
                      <tr style={{ textAlign:'left', color:'#495057' }}>
                        <th style={{ padding:8 }}>#</th>
                        <th style={{ padding:8 }}>Descrição</th>
                        <th style={{ padding:8 }}>Equipe</th>
                        <th style={{ padding:8 }}>Categoria</th>
                        <th style={{ padding:8 }}>Valor</th>
                        <th style={{ padding:8 }}>Status</th>
                        <th style={{ padding:8 }}>Risco</th>
                        <th style={{ padding:8, textAlign:'right' }}>Ações</th>
                      </tr>
                    </thead>
                    <tbody>
                      {mine.length===0 && <tr><td colSpan="8" style={{ padding:8, color:'#6c757d' }}>Nenhum registro encontrado</td></tr>}
                      {mine.map((d,i)=> (
                        <tr key={d.id} style={{ borderTop:'1px solid #e9ecef' }}>
                          <td style={{ padding:8 }}>{i+1}</td>
                          <td style={{ padding:8 }}>{d.description}</td>
                          <td style={{ padding:8 }}>{d.team || '-'}</td>
                          <td style={{ padding:8 }}>{d.category}</td>
                          <td style={{ padding:8 }}>{d.category==='fundos' ? `R$ ${d.amount.toFixed(2)}` : `${d.amount} ${d.unit||''}`}</td>
                          <td style={{ padding:8 }}>{d.status}</td>
                          <td style={{ padding:8 }}>
                            <span className={`risk-badge ${d.riskClass || 'risk-low'}`} title={`Score ${d.riskScore || 0}`}>
                              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 2L2 22h20L12 2z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
                              {d.riskLevel || 'Baixo'}
                            </span>
                          </td>
                          <td style={{ padding:8, textAlign:'right' }}>
                            <div style={{ display:'inline-flex', gap:8, alignItems:'center' }}>
                              <button className="btn btn-ghost btn-sm" type="button" onClick={()=>setSuccess(`Registro #${d.id} possui ${d.photos?.length||0} evidência(s).`)}>Ver status</button>
                              {d.needsEvidence && (
                                <label className="btn btn-sm" style={{ cursor:'pointer' }}>
                                  Anexar Evidências
                                  <input
                                    type="file"
                                    accept="image/*"
                                    multiple
                                    onChange={(e)=>{ const files = e.target.files; addEvidence(d.id, files); e.target.value=''; }}
                                    style={{ display:'none' }}
                                  />
                                </label>
                              )}
                            </div>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </Card>
            </div>
            {/* Resumo: subtotais por status e totais aprovados por categoria */}
            <div className="card" style={{ marginTop:16 }}>
              {(() => {
                const pend = mine.filter(d=>d.status==='Pendente').length;
                const apro = mine.filter(d=>d.status==='Aprovada').length;
                const rej = mine.filter(d=>d.status==='Rejeitada').length;
                const approved = mine.filter(d=>d.status==='Aprovada');
                const food = approved.filter(d=>d.category==='alimento').reduce((s,d)=>s+(d.amount||0),0);
                const funds = approved.filter(d=>d.category==='fundos').reduce((s,d)=>s+(d.amount||0),0);
                const toys = approved.filter(d=>d.category==='brinquedos').reduce((s,d)=>s+(d.amount||0),0);
                return (
                  <div className="anim-fade">
                    <div style={{ fontWeight:700, marginBottom:8, color:'#0f5132' }}>Resumo</div>
                    <div style={{ display:'grid', gridTemplateColumns:'repeat(3, 1fr)', gap:12 }}>
                      <div className="card" style={{ padding:12 }}><div style={{ color:'#0f5132', fontWeight:700 }}>Pendentes</div><div style={{ fontSize:22, fontWeight:800 }}>{pend}</div></div>
                      <div className="card" style={{ padding:12 }}><div style={{ color:'#0f5132', fontWeight:700 }}>Aprovadas</div><div style={{ fontSize:22, fontWeight:800 }}>{apro}</div></div>
                      <div className="card" style={{ padding:12 }}><div style={{ color:'#0f5132', fontWeight:700 }}>Rejeitadas</div><div style={{ fontSize:22, fontWeight:800 }}>{rej}</div></div>
                    </div>
                    <div style={{ marginTop:12, display:'grid', gridTemplateColumns:'repeat(3, 1fr)', gap:12 }}>
                      <div className="card" style={{ padding:12 }}><div style={{ color:'#0f5132', fontWeight:700 }}>Alimentos (kg) aprovados</div><div style={{ fontSize:22, fontWeight:800 }}>{food.toFixed(2)}</div></div>
                      <div className="card" style={{ padding:12 }}><div style={{ color:'#0f5132', fontWeight:700 }}>Fundos (R$) aprovados</div><div style={{ fontSize:22, fontWeight:800 }}>{funds.toFixed(2)}</div></div>
                      <div className="card" style={{ padding:12 }}><div style={{ color:'#0f5132', fontWeight:700 }}>Brinquedos (un) aprovados</div><div style={{ fontSize:22, fontWeight:800 }}>{toys}</div></div>
                    </div>
                    {mine.some(d=>d.needsEvidence) && (
                      <div style={{ marginTop:16, padding:16 }} className="card">
                        <div className="subtitle">Evidências Pendentes</div>
                        <div className="muted" style={{ fontSize:13, marginTop:4 }}>Envie fotos extras para as doações destacadas acima. Isso ajuda a evitar fraudes e acelera a aprovação.</div>
                      </div>
                    )}
                  </div>
                );
              })()}
            </div>
          </div>
        );
      }

      // === Mentor: aprovação de doações pendentes ===
      function MentorApprovalSection({ user }) {
        const [pending, setPending] = useState([]);
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState('');
        const [viewerPhotos, setViewerPhotos] = useState(null);
        const [feedback, setFeedback] = useState('');
        const tbodyRef = React.useRef(null);

        const load = async () => {
          setLoading(true); 
          setError(''); 
          setFeedback('');
          
          try { 
            // Carregar doações pendentes via API
            const result = await api.getDoacoes({ status: 'pendente' });
            setPending(result.data || []); 
          } catch (e) { 
            console.error('Erro ao carregar doações:', e);
            setError('Erro ao carregar doações: ' + e.message); 
          } finally { 
            setLoading(false); 
          }
        };
        useEffect(()=>{ load(); }, [user]);

        useEffect(()=>{
          const tbody = tbodyRef.current;
          if (!tbody) return;
          const onClick = (e) => {
            const tr = e.target.closest('tr[data-id]');
            if (!tr) return;
            const id = tr.getAttribute('data-id');
            const isSelected = tr.classList.contains('linha-selecionada');
            Array.from(tbody.querySelectorAll('tr[data-id]')).forEach(row => row.classList.remove('linha-selecionada'));
            if (isSelected) {
              tr.classList.remove('linha-selecionada');
            } else {
              tr.classList.add('linha-selecionada');
            }
          };
          tbody.addEventListener('click', onClick);
          return () => tbody.removeEventListener('click', onClick);
        }, [tbodyRef]);

        const doApprove = async (id) => { 
          try {
            const observacoes = prompt('Observações (opcional):') || '';
            await api.aprovarDoacao(id, observacoes);
            setFeedback('Doação aprovada com sucesso.');
            load();
          } catch (error) {
            setError('Erro ao aprovar doação: ' + error.message);
          }
        };
        
        const doReject = async (id) => {
          try {
            const motivo = prompt('Motivo da rejeição:');
            if (!motivo) return;
            
            await api.rejeitarDoacao(id, motivo);
            setFeedback('Doação rejeitada. Histórico atualizado.');
            load();
          } catch (error) {
            setError('Erro ao rejeitar doação: ' + error.message);
          }
        };
        const requestEvidence = (id) => {
          const reason = prompt('Descreva o que precisa ser comprovado:') || 'Verificação adicional solicitada';
          flagDonationForEvidence(id, 'Mentor/Admin', reason);
          setFeedback('Evidências adicionais solicitadas. O participante foi notificado.');
          load();
        };
        const openPhotos = (donation) => {
          const photos = donation?.photos || [];
          if (photos.length > 0) setViewerPhotos(photos);
        };

        return (
          <div className="container" style={{ paddingTop: 16 }}>
            <Card title={`Aprovação de Doações - ${user?.team || 'Grupo não definido'}`} right={<button className="btn" onClick={load}>Atualizar</button>}>
              {loading && <span>Carregando…</span>}
              {error && <div style={{ color:'#dc3545' }}>{error}</div>}
              {feedback && <div style={{ color:'#4df2c2', marginBottom:8 }}>{feedback}</div>}
              <div style={{ overflowX:'auto', marginTop:0 }}>
                <table style={{ width:'100%', borderCollapse:'collapse' }}>
                  <thead>
                    <tr style={{ textAlign:'left', color:'#495057' }}>
                      <th style={{ padding:8 }}>#</th>
                      <th style={{ padding:8 }}>Descrição</th>
                      <th style={{ padding:8 }}>Equipe</th>
                      <th style={{ padding:8 }}>Categoria</th>
                      <th style={{ padding:8 }}>Valor</th>
                      <th style={{ padding:8 }}>Aluno</th>
                      <th style={{ padding:8 }}>Risco</th>
                      <th style={{ padding:8 }}>Evidências</th>
                      <th style={{ padding:8, textAlign:'right' }}>Ações</th>
                    </tr>
                  </thead>
                  <tbody ref={tbodyRef}>
                    {!loading && pending.length===0 && (
                      <tr><td colSpan="9" style={{ padding:8, color:'#6c757d' }}>Nenhum registro encontrado</td></tr>
                    )}
                    {pending.map((p, i) => (
                      <tr key={p.id} data-id={p.id} style={{ borderTop:'1px solid #e9ecef' }}>
                        <td style={{ padding:8 }}>{i+1}</td>
                        <td style={{ padding:8 }}>{p.description}</td>
                        <td style={{ padding:8 }}>{p.team || '-'}</td>
                        <td style={{ padding:8 }}>{p.category}</td>
                        <td style={{ padding:8 }}>{p.category==='fundos' ? `R$ ${p.amount.toFixed(2)}` : `${p.amount} ${p.unit||''}`}</td>
                        <td style={{ padding:8 }}>{p.user?.name || '-'}</td>
                        <td style={{ padding:8 }}>
                          <span className={`risk-badge ${p.riskClass || 'risk-low'}`} title={`Score ${p.riskScore || 0}`}>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 2L2 22h20L12 2z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
                            {p.riskLevel || 'Baixo'}
                          </span>
                        </td>
                        <td style={{ padding:8 }}>
                          <span className="chip">{p.photos?.length || 0} foto(s)</span>
                          {p.needsEvidence && <span className="badge" style={{ marginLeft:8 }}>Evidência pendente</span>}
                        </td>
                        <td style={{ padding:8 }}>
                          <div style={{ display:'inline-flex', gap:8, alignItems:'center' }}>
                            {p.photos && p.photos.length > 0 && (
                              <button
                                className="btn btn-ghost btn-sm"
                                onClick={()=>openPhotos(p)}
                              >
                                Visualizar
                              </button>
                            )}
                            {p.needsEvidence && (
                              <button className="btn btn-ghost btn-sm" onClick={()=>requestEvidence(p.id)}>Reforçar pedido</button>
                            )}
                            {!p.needsEvidence && (
                              <button className="btn btn-ghost btn-sm" onClick={()=>requestEvidence(p.id)}>Solicitar evidência</button>
                            )}
                            <button className="btn btn-sm" onClick={()=>doApprove(p.id)}>Aprovar</button>
                            <button className="btn btn-danger btn-sm" onClick={()=>doReject(p.id)}>Rejeitar</button>
                          </div>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </Card>
            {viewerPhotos && (
              <div style={{ position:'fixed', inset:0, background:'rgba(0,0,0,0.5)', display:'flex', alignItems:'center', justifyContent:'center', padding:16, zIndex:2000 }} onClick={()=>setViewerPhotos(null)}>
                <div className="card anim-scale" style={{ maxWidth:900, width:'100%', maxHeight:'90vh', overflow:'auto', padding:16 }} onClick={(e)=>e.stopPropagation()}>
                  <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:8 }}>
                    <div style={{ fontWeight:700, color:'#0f5132' }}>Fotos do Registro</div>
                    <button className="btn" onClick={()=>setViewerPhotos(null)}>Fechar</button>
                  </div>
                  <div style={{ display:'flex', gap:12, flexWrap:'wrap' }}>
                    {viewerPhotos.map((src, idx) => (
                      <img key={idx} src={src} alt={`Foto ${idx+1}`} style={{ width:160, height:160, objectFit:'cover', borderRadius:10, border:'1px solid #e9ecef' }} />
                    ))}
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      // === Admin Dashboard (KPIs + Charts + Ranking) ===
      function AnimatedNumber({ value, duration=600, format=(v)=>v, className='' }) {
        const [displayValue, setDisplayValue] = useState(0);
        const [isVisible, setIsVisible] = useState(false);
        const [isHovered, setIsHovered] = useState(false);
        const ref = useRef();
      
        useEffect(() => {
          const observer = new IntersectionObserver(
            ([entry]) => {
              if (entry.isIntersecting) {
                setIsVisible(true);
                observer.disconnect();
              }
            },
            { threshold: 0.1 }
          );
          if (ref.current) observer.observe(ref.current);
          return () => observer.disconnect();
        }, []);
      
        useEffect(() => {
          if (!isVisible) return;
          
          let start = 0;
          const end = typeof value === 'number' ? value : 0;
          const startTime = performance.now();
          
          const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            const easeOutQuad = t => t * (2 - t);
            const currentValue = start + (end - start) * easeOutQuad(progress);
            
            setDisplayValue(currentValue);
            
            if (progress < 1) {
              requestAnimationFrame(animate);
            } else {
              setDisplayValue(end); // Garante que termine exatamente no valor final
            }
          };
          
          requestAnimationFrame(animate);
          
          return () => cancelAnimationFrame(animate);
        }, [value, duration, isVisible]);
      
        return (
          <span 
            ref={ref} 
            className={className}
            style={{
              display: 'inline-block',
              transition: 'transform 0.2s ease, color 0.3s ease',
              transform: isHovered ? 'scale(1.1)' : 'scale(1)',
              color: isHovered ? '#4df2c2' : 'inherit'
            }}
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
          >
            {format ? format(displayValue) : displayValue.toLocaleString()}
          </span>
        );
      }
      
      // Componente de cartão de estatísticas
      function StatCard({ title, value, icon, color = '#4df2c2', format, description }) {
        const [isHovered, setIsHovered] = useState(false);
        
        return (
          <div 
            className="stat-card"
            style={{
              borderLeft: `4px solid ${color}`,
              transform: isHovered ? 'translateY(-5px)' : 'none',
              background: isHovered ? 'rgba(77, 242, 194, 0.03)' : 'var(--card-bg)'
            }}
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
          >
            <div style={{ display: 'flex', alignItems: 'center', marginBottom: 12 }}>
              <div 
                className="stat-icon"
                style={{
                  background: isHovered ? `${color}20` : `${color}10`,
                  transform: isHovered ? 'rotate(10deg)' : 'none'
                }}
              >
                <i className={icon} style={{ color, fontSize: '20px' }} />
              </div>
              <div style={{ flex: 1 }}>
                <div className="stat-label">{title}</div>
                <div className="stat-value">
                  <AnimatedNumber 
                    value={value} 
                    format={format} 
                    className={isHovered ? 'pulse' : ''}
                  />
                </div>
              </div>
            </div>
            {description && (
              <div style={{
                fontSize: '12px',
                color: 'var(--text-muted)',
                marginTop: '8px',
                paddingTop: '8px',
                borderTop: '1px dashed rgba(77, 242, 194, 0.2)'
              }}>
                {description}
              </div>
            )}
          </div>
        );
      }

      function useRevealOnScroll() {
        useEffect(() => {
          const els = Array.from(document.querySelectorAll('.reveal'));
          if (!('IntersectionObserver' in window)) {
            els.forEach(el => el.classList.add('in-view'));
            return;
          }
          const io = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
              if (entry.isIntersecting) entry.target.classList.add('in-view');
            });
          }, { rootMargin: '0px 0px -10% 0px', threshold: 0.1 });
          els.forEach(el => io.observe(el));
          return () => io.disconnect();
        }, []);
      }

      function AdminDashboard() {
        useRevealOnScroll();
        const [leaders, setLeaders] = useState([]);
        const [donations, setDonations] = useState([]);
        const [periodDays, setPeriodDays] = useState(30); // 7 | 30 | 90 | 0 (todos)
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState("");
        const BASE_URL = (window.__ENV && window.__ENV.API_URL) || 'http://localhost:3001';

        useEffect(() => {
          const loadData = () => {
            setLoading(true);
            setError("");
            
            try {
              // Carrega dados mock de líderes se não existirem
              const mockLeaders = [
                { id: 1, name: 'Ana Silva', role: 'mentor', team: 'Equipe Alpha', email: 'ana@exemplo.com' },
                { id: 2, name: 'João Santos', role: 'aluno', team: 'Equipe Beta', email: 'joao@exemplo.com' },
                { id: 3, name: 'Maria Costa', role: 'mentor', team: 'Equipe Gamma', email: 'maria@exemplo.com' },
                { id: 4, name: 'Pedro Lima', role: 'aluno', team: 'Equipe Alpha', email: 'pedro@exemplo.com' },
                { id: 5, name: 'Carla Souza', role: 'aluno', team: 'Equipe Beta', email: 'carla@exemplo.com' }
              ];
              
              setLeaders(mockLeaders);
              
              // Adiciona doações mock se não existirem
              const existingDonations = listAllDonations();
              if (existingDonations.length === 0) {
                const mockDonations = [
                  {
                    id: 'mock1',
                    description: 'Doação de alimentos',
                    amount: 50,
                    category: 'alimento',
                    team: 'Equipe Alpha',
                    status: 'Aprovada',
                    user: { name: 'João Santos' },
                    createdAt: new Date(Date.now() - 2*24*60*60*1000).toISOString(),
                    updatedAt: new Date(Date.now() - 1*24*60*60*1000).toISOString()
                  },
                  {
                    id: 'mock2',
                    description: 'Doação em dinheiro',
                    amount: 200,
                    category: 'fundos',
                    team: 'Equipe Beta',
                    status: 'Aprovada',
                    user: { name: 'Maria Costa' },
                    createdAt: new Date(Date.now() - 5*24*60*60*1000).toISOString(),
                    updatedAt: new Date(Date.now() - 4*24*60*60*1000).toISOString()
                  },
                  {
                    id: 'mock3',
                    description: 'Doação de brinquedos',
                    amount: 15,
                    category: 'brinquedos',
                    team: 'Equipe Gamma',
                    status: 'Pendente',
                    user: { name: 'Ana Silva' },
                    createdAt: new Date(Date.now() - 1*24*60*60*1000).toISOString()
                  }
                ];
                
                // Salva as doações mock no localStorage
                lsSet(LS_KEYS.DONATIONS, mockDonations);
                setDonations(mockDonations);
              } else {
                setDonations(existingDonations);
              }
              
              console.log('✅ Dados do admin carregados com sucesso');
            } catch (e) { 
              setError(e.message || 'Erro ao carregar dados');
              console.error('❌ Erro ao carregar dados do admin:', e);
            } finally { 
              setLoading(false); 
            }
          };

          loadData();

          const onStorage = (e) => {
            if (e.key === 'gl_donations' || e.key === 'gl_donations_pending' || e.key === 'gl_donations_recent') {
              setDonations(listAllDonations());
            }
          };
          
          window.addEventListener('storage', onStorage);
          return () => {
            window.removeEventListener('storage', onStorage);
          };
        }, []);

        // Agrupamentos por equipe e por role
        // Ranking: baseado em doações APROVADAS por equipe (valores por categoria)
        const approved = donations.filter(d => d.status === 'Aprovada');
        // Janela de período
        const nowTs = Date.now();
        const fromTs = periodDays && periodDays > 0 ? nowTs - periodDays*24*3600*1000 : 0;
        const approvedWindow = approved.filter(d => {
          const ts = new Date(d.updatedAt || d.updated_at || d.createdAt || d.created_at || 0).getTime();
          return fromTs === 0 || ts >= fromTs;
        });
        const donationsByTeam = approvedWindow.reduce((acc, d) => {
          const team = d.team || '—';
          acc[team] = acc[team] || { food:0, funds:0, toys:0 };
          if (d.category==='alimento') acc[team].food += (d.amount||0);
          else if (d.category==='fundos') acc[team].funds += (d.amount||0);
          else if (d.category==='brinquedos') acc[team].toys += (d.amount||0);
          return acc;
        }, {});
        // ainda computamos byRole para KPIs de leaders
        const byTeam = Object.fromEntries(Object.entries(donationsByTeam).map(([team, v]) => [team, (v.food||0)+(v.funds||0)+(v.toys||0)]));
        const byRole = leaders.reduce((acc, l) => { const k = l.role || '—'; acc[k] = (acc[k] || 0) + 1; return acc; }, {});
        const teamsData = Object.entries(byTeam).map(([name, total]) => ({ name, total }));

        // KPIs
        const totalLeaders = leaders.length;
        const totalAlunos = byRole['aluno'] || byRole['Aluno'] || 0;
        const totalMentores = byRole['mentor'] || byRole['Mentor'] || 0;

        // KPIs de Doações por categoria (apenas Aprovadas)
        const dFood = approvedWindow.filter(d=>d.category==='alimento').reduce((s,d)=>s+(d.amount||0),0);
        const dFunds = approvedWindow.filter(d=>d.category==='fundos').reduce((s,d)=>s+(d.amount||0),0);
        const dToys = approvedWindow.filter(d=>d.category==='brinquedos').reduce((s,d)=>s+(d.amount||0),0);
        const byCategory = [
          { name: 'Alimentos (kg)', total: dFood },
          { name: 'Fundos (R$)', total: dFunds },
          { name: 'Brinquedos (un)', total: dToys }
        ];
        // Resumo por status
        const cPending = donations.filter(d=>d.status==='Pendente').length;
        const cApproved = approved.length;
        const cRejected = donations.filter(d=>d.status==='Rejeitada').length;

        // KPI avançados: taxa de aprovação, tempo médio de aprovação, pendências antigas
        const approvalRate = (cApproved + cRejected) > 0 ? (cApproved / (cApproved + cRejected)) : 0;
        const avgApprovalMs = (() => {
          const times = approved
            .map(d => {
              const created = new Date(d.createdAt || d.created_at || Date.now());
              const updated = new Date(d.updatedAt || d.updated_at || d.createdAt || Date.now());
              return Math.max(0, updated - created);
            })
            .filter(v => Number.isFinite(v) && v>0);
          if (!times.length) return 0;
          return times.reduce((s,v)=>s+v,0) / times.length;
        })();
        const avgApprovalHours = avgApprovalMs / (1000*60*60);
        const agingPend = donations
          .filter(d => d.status==='Pendente')
          .map(d => ({ d, ageDays: (Date.now() - new Date(d.createdAt || d.created_at || Date.now()))/(1000*60*60*24) }))
          .filter(x => x.ageDays >= 3)
          .length;

        // Trend: aprovadas por dia (período selecionado; mínimo 14 dias), usando updatedAt (ou createdAt)
        function startOfDay(ts){ const d = new Date(ts); d.setHours(0,0,0,0); return d.getTime(); }
        const today = startOfDay(Date.now());
        const span = Math.max(14, periodDays || 14);
        const days = Array.from({length:span}).map((_,i)=> today - (span-1-i)*24*3600*1000);
        const approvalsByDay = days.map(day => {
          const next = day + 24*3600*1000;
          const total = approvedWindow.filter(d => {
            const stamp = new Date(d.updatedAt || d.updated_at || d.createdAt || d.created_at || Date.now()).getTime();
            return stamp >= day && stamp < next;
          }).length;
          return { day, total };
        });
        const maxTrend = Math.max(1, ...approvalsByDay.map(p=>p.total));

        // Risco agregado
        const riskyDonations = donations.filter(d => (d.riskLevel === 'Alto') && d.status === 'Pendente');
        const mediumRisk = donations.filter(d => (d.riskLevel === 'Médio') && d.status === 'Pendente');
        const evidenceWaiting = donations.filter(d => d.needsEvidence).length;
        const auditEvents = listAuditTrail(8);

        // Crescimento 7d por equipe
        const sevenAgo = Date.now() - 7*24*3600*1000;
        const approved7 = approved.filter(d => new Date(d.updatedAt || d.updated_at || d.createdAt || 0).getTime() >= sevenAgo);
        const totalsNow = donationsByTeam;
        const totals7 = approved7.reduce((acc, d) => {
          const team = d.team || '—';
          acc[team] = acc[team] || { food:0, funds:0, toys:0 };
          if (d.category==='alimento') acc[team].food += (d.amount||0);
          else if (d.category==='fundos') acc[team].funds += (d.amount||0);
          else if (d.category==='brinquedos') acc[team].toys += (d.amount||0);
          return acc;
        }, {});
        function growthFor(team){
          const now = totalsNow[team] || {food:0,funds:0,toys:0};
          const last = totals7[team] || {food:0,funds:0,toys:0};
          const nowSum = (now.food||0)+(now.funds||0)+(now.toys||0);
          const lastSum = (last.food||0)+(last.funds||0)+(last.toys||0);
          return lastSum; // crescimento absoluto na última semana
        }

        // Atividade recente (últimos 10 eventos)
        const recent = [...donations]
          .filter(d => d.updatedAt || d.createdAt)
          .sort((a,b)=> new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt))
          .slice(0,10);

        // Cores para gráficos
        const COLORS = ['#006400', '#0E7A0D', '#1E9E1B', '#2ECF25', '#65DB6B', '#A0E7A5'];

        // Pie chart: calcula arcos
        function PieChartSVG({ data, size=260, inner=0 }) {
          const radius = size/2; const cx = radius; const cy = radius; const total = data.reduce((s, d)=>s+d.total,0) || 1;
          let angleStart = -Math.PI/2; // começa no topo
          const paths = [];
          data.forEach((d, i) => {
            const angle = (d.total/total) * Math.PI * 2;
            const angleEnd = angleStart + angle;
            const x1 = cx + radius * Math.cos(angleStart);
            const y1 = cy + radius * Math.sin(angleStart);
            const x2 = cx + radius * Math.cos(angleEnd);
            const y2 = cy + radius * Math.sin(angleEnd);
            const large = angle > Math.PI ? 1 : 0;
            const dPath = `M ${cx} ${cy} L ${x1} ${y1} A ${radius} ${radius} 0 ${large} 1 ${x2} ${y2} Z`;
            paths.push(<path key={i} d={dPath} fill={COLORS[i % COLORS.length]} opacity="0.95"></path>);
            angleStart = angleEnd;
          });
          return (
            <svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>{paths}</svg>
          );
        }

        // Bar chart simples
        function BarChart({ data, height=260 }) {
          const max = Math.max(...data.map(d=>d.total), 1);
          return (
            <div style={{ display:'grid', gridTemplateRows: `${height}px auto`, gap:8 }}>
              <div style={{ display:'grid', gridAutoFlow:'column', alignItems:'end', gap:12, height }}>
                {data.map((d, i) => (
                  <div
                    key={d.name}
                    className="anim-fade reveal"
                    style={{
                      background:'#198754',
                      width:24,
                      height: Math.max(6, (d.total/max)*height),
                      borderRadius:6,
                      transition: 'height .6s ease, transform .2s ease',
                    }}
                    title={`${d.name}: ${d.total}`}
                  />
                ))}
              </div>
              <div style={{ display:'grid', gridAutoFlow:'column', gap:12, fontSize:12, color:'#495057' }}>
                {data.map(d => <div key={d.name} style={{ writingMode:'vertical-rl', transform:'rotate(180deg)', textAlign:'center' }}>{d.name}</div>)}
              </div>
            </div>
          );
        }

        // Ranking controls: estado no componente
        const [rankBy, setRankBy] = useState('alimento'); // 'alimento' | 'fundos' | 'brinquedos'
        function RankingControls(){
          return (
            <div style={{ display:'flex', gap:8, alignItems:'center' }}>
              <span style={{ color:'#495057', fontSize:14 }}>Ordenar por</span>
              <select className="input" style={{ padding:'6px 10px', width:160 }} value={rankBy} onChange={(e)=>setRankBy(e.target.value)}>
                <option value="alimento">Alimentos (kg)</option>
                <option value="fundos">Fundos (R$)</option>
                <option value="brinquedos">Brinquedos (un)</option>
              </select>
            </div>
          );
        }
        function getRankingRows(){
          const rows = Object.entries(donationsByTeam).map(([team, v]) => ({ team, food: v.food||0, funds: v.funds||0, toys: v.toys||0 }));
          const key = rankBy==='alimento' ? 'food' : rankBy==='fundos' ? 'funds' : 'toys';
          return rows.sort((a,b)=> (b[key] - a[key]));
        }

        return (
          <div className="container" style={{ paddingTop: 0 }}>
            {/* Header + Filtros + Atualizar */}
            <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:8 }}>
              <div style={{ fontWeight:800, color:'#0f5132' }}>Painel do Administrador</div>
              <div style={{ display:'flex', gap:8, alignItems:'center' }}>
                <select className="input" style={{ width:160, padding:'6px 10px' }} value={periodDays} onChange={(e)=>setPeriodDays(parseInt(e.target.value,10))}>
                  <option value={7}>Últimos 7 dias</option>
                  <option value={30}>Últimos 30 dias</option>
                  <option value={90}>Últimos 90 dias</option>
                  <option value={0}>Todos</option>
                </select>
                <button className="btn" onClick={()=>{
                  // Recarrega leaders e donations
                  (async () => {
                    try {
                      const res = await fetch(`${BASE_URL}/api/leaders`);
                      const json = await res.json();
                      if (res.ok) setLeaders(json.data || []);
                    } catch {}
                    setDonations(listAllDonations());
                  })();
                }}>Atualizar</button>
                <button className="btn btn-ghost" onClick={()=>{
                  const rows = getRankingRows().map((row, i) => ({
                    rank: i+1,
                    team: row.team,
                    alimentos_kg: row.food.toFixed(2),
                    fundos_rs: row.funds.toFixed(2),
                    brinquedos_un: row.toys,
                    crescimento_7d: (growthFor(row.team)).toFixed(2)
                  }));
                  const headers = Object.keys(rows[0] || { rank:'', team:'', alimentos_kg:'', fundos_rs:'', brinquedos_un:'', crescimento_7d:'' });
                  const csv = [headers.join(','), ...rows.map(r => headers.map(h => `${String(r[h]).replace(/"/g,'""')}`).join(','))].join('\n');
                  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement('a');
                  a.href = url; a.download = `ranking_equipes_${periodDays||'todos'}d.csv`;
                  document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                }}>Exportar CSV</button>
              </div>
            </div>

            {/* KPIs de Leaders + avançados */}
            <div className="grid-auto" style={{ marginBottom: '16px', gap: '16px' }}>
              <div className="col-3">
                <StatCard 
                  title="Total de Leaders" 
                  value={totalLeaders}
                  icon="fas fa-users"
                  description="Equipe cadastrada"
                  color="#4d9df2"
                />
              </div>
              <div className="col-3">
                <StatCard 
                  title="Alunos" 
                  value={totalAlunos}
                  icon="fas fa-user-graduate"
                  description="Contas de aluno"
                  color="#9d4dff"
                />
              </div>
              <div className="col-3">
                <StatCard 
                  title="Mentores" 
                  value={totalMentores}
                  icon="fas fa-chalkboard-teacher"
                  description="Contas de mentor"
                  color="#4dffb8"
                />
              </div>
              <div className="col-3">
                <StatCard 
                  title="Taxa de Aprovação" 
                  value={approvalRate*100}
                  format={(v) => `${v.toFixed(0)}%`}
                  icon="fas fa-check-circle"
                  description="Aprovadas / Total"
                  color="#4df24d"
                />
              </div>
            </div>

            {/* KPIs de Doações + operacionais */}
            <div className="grid-auto" style={{ marginBottom: '16px', gap: '16px' }}>
              <div className="col-3">
                <StatCard 
                  title="Alimentos" 
                  value={dFood}
                  format={(v) => v.toFixed(2)}
                  icon="fas fa-apple-alt"
                  description="Total em kg"
                  color="#ff9d4d"
                  duration={900}
                  suffix=" kg"
                />
              </div>
              <div className="col-3">
                <StatCard 
                  title="Fundos" 
                  value={dFunds}
                  format={(v) => v.toFixed(2)}
                  icon="fas fa-coins"
                  description="Total arrecadado"
                  color="#ffd54d"
                  duration={900}
                  prefix="R$ "
                />
              </div>
              <div className="col-3">
                <StatCard 
                  title="Brinquedos" 
                  value={dToys}
                  icon="fas fa-gamepad"
                  description="Unidades doadas"
                  color="#ff4d9d"
                  suffix=" un"
                />
              </div>
              <div className="col-3">
                <StatCard 
                  title="Tempo de Aprovação" 
                  value={avgApprovalHours}
                  format={(v) => v.toFixed(1)}
                  icon="fas fa-clock"
                  description="Média de horas"
                  color="#4db8ff"
                  suffix=" h"
                />
              </div>
            </div>

            {/* Resumo de Status */}
            <div className="grid-auto" style={{ marginBottom: '16px', gap: '16px' }}>
              <div className="col-4">
                <StatCard 
                  title="Pendentes"
                  value={cPending}
                  icon="fas fa-clock"
                  description={agingPend > 0 ? `${agingPend} aguardando +3d` : 'Aguardando revisão'}
                  color="#ff9d4d"
                  badge={agingPend > 0 ? `${agingPend} 3d+` : null}
                  badgeColor="#ff3b30"
                />
              </div>
              <div className="col-4">
                <StatCard 
                  title="Aprovadas"
                  value={cApproved}
                  icon="fas fa-check-circle"
                  description="Doações validadas"
                  color="#4df24d"
                />
              </div>
              <div className="col-4">
                <StatCard 
                  title="Rejeitadas"
                  value={cRejected}
                  icon="fas fa-times-circle"
                  description="Não aprovadas"
                  color="#ff4d4d"
                />
              </div>
            </div>

            {/* Cards de Risco/Auditoria */}
            <div className="grid-auto" style={{ marginBottom: '16px', gap: '16px' }}>
              <div className="col-4">
                <StatCard 
                  title="Risco Alto Pendentes"
                  value={riskyDonations.length}
                  icon="fas fa-exclamation-triangle"
                  description="Doações com score alto"
                  color="#ff3b30"
                  badge={riskyDonations.length > 0 ? "Atenção imediata" : null}
                  badgeColor="#ff3b30"
                  pulse={riskyDonations.length > 0}
                />
              </div>
              <div className="col-4">
                <StatCard 
                  title="Risco Médio"
                  value={mediumRisk.length}
                  icon="fas fa-exclamation-circle"
                  description="Revisão recomendada"
                  color="#ff9500"
                  badge={mediumRisk.length > 0 ? `${mediumRisk.length} pendentes` : null}
                  badgeColor="#ff9500"
                />
              </div>
              <div className="col-4">
                <StatCard 
                  title="Evidências Pendentes"
                  value={evidenceWaiting}
                  icon="fas fa-paperclip"
                  description="Aguardando documentos"
                  color="#5ac8fa"
                  badge={evidenceWaiting > 0 ? `${evidenceWaiting} itens` : null}
                  badgeColor="#5ac8fa"
                />
              </div>
            </div>

            <div className="card anim-fade reveal" style={{ marginTop:16 }}>
              <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:8 }}>
                <div className="subtitle">Linha do tempo de Auditoria</div>
                <button className="btn btn-ghost btn-sm" onClick={()=>{
                  const csvEvents = listAuditTrail(100).map(ev => ({
                    id: ev.id,
                    doacao: ev.donationId,
                    acao: ev.action,
                    ator: ev.actor,
                    horario: ev.timestamp,
                    detalhes: JSON.stringify(ev.extra || {})
                  }));
                  const headers = Object.keys(csvEvents[0] || { id:'', doacao:'', acao:'', ator:'', horario:'', detalhes:'' });
                  const csv = [headers.join(','), ...csvEvents.map(r => headers.map(h => `${String(r[h]).replace(/"/g,'""')}`).join(','))].join('\n');
                  const blob = new Blob([csv], { type:'text/csv;charset=utf-8;' });
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement('a');
                  a.href = url; a.download = `auditoria_${Date.now()}.csv`;
                  document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                }}>Exportar auditoria</button>
              </div>
              {auditEvents.length === 0 ? (
                <div className="muted">Nenhum evento registrado ainda.</div>
              ) : (
                <div className="audit-timeline">
                  {auditEvents.map(ev => (
                    <div key={ev.id} className="audit-timeline-item">
                      <div className="audit-icon">⏵</div>
                      <div>
                        <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center' }}>
                          <strong>{ev.action}</strong>
                          <span>{new Date(ev.timestamp).toLocaleString()}</span>
                        </div>
                        <div className="muted" style={{ fontSize:12 }}>Doação #{ev.donationId} • {ev.actor}</div>
                        {ev.extra && Object.keys(ev.extra).length > 0 && (
                          <div style={{ marginTop:4, fontSize:12, color:'#f0fff8' }}>{Object.entries(ev.extra).map(([k,v])=>`${k}: ${typeof v==='object'?JSON.stringify(v):v}`).join(' • ')}</div>
                        )}
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>

            {/* Charts */}
            <div className="grid-auto" style={{ marginTop:16 }}>
              <div className="card anim-scale reveal col-6">
                <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center' }}>
                  <div className="subtitle">Doações por Categoria</div>
                  <span className="chip">Somente aprovadas</span>
                </div>
                {byCategory.some(c=>c.total>0) ? <PieChartSVG data={byCategory} /> : <span style={{ color:'#6c757d' }}>Nenhum dado</span>}
              </div>
              <div className="card anim-scale reveal col-6">
                <div className="subtitle" style={{ marginBottom:8 }}>Totais por Categoria</div>
                {byCategory.some(c=>c.total>0) ? <BarChart data={byCategory} /> : <span style={{ color:'#6c757d' }}>Nenhum dado</span>}
              </div>
            </div>

            {/* Trend: aprovações por dia (14d) */}
            <div className="card anim-fade reveal" style={{ marginTop:16 }}>
              <div className="subtitle" style={{ marginBottom:8 }}>Aprovações nos últimos 14 dias</div>
              {(() => {
                const width = 760; const height = 220; const padding = 24; const maxY = maxTrend;
                const points = approvalsByDay.map((p,i)=>{
                  const x = padding + (i/(approvalsByDay.length-1))*(width - padding*2);
                  const y = padding + (1 - (p.total / maxY))*(height - padding*2);
                  return { x, y, v: p.total };
                });
                const path = points.map((pt,i)=> `${i===0?'M':'L'} ${pt.x} ${pt.y}`).join(' ');
                return (
                  <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`} style={{ width:'100%', height:'auto' }}>
                    <defs>
                      <linearGradient id="g" x1="0" x2="0" y1="0" y2="1">
                        <stop offset="0%" stopColor="#198754" stopOpacity="0.28" />
                        <stop offset="100%" stopColor="#198754" stopOpacity="0.02" />
                      </linearGradient>
                    </defs>
                    <path d={path} fill="none" stroke="#198754" strokeWidth="2" />
                    <path d={`${path} L ${width-padding} ${height-padding} L ${padding} ${height-padding} Z`} fill="url(#g)" opacity="0.8" />
                    {points.map((pt,i)=> (
                      <g key={i}>
                        <circle cx={pt.x} cy={pt.y} r="3" fill="#0f5132" />
                      </g>
                    ))}
                  </svg>
                );
              })()}
            </div>

            {/* Ranking por Doações Aprovadas (ordenar por categoria) */}
            <div className="card anim-fade reveal" style={{ marginTop:16 }}>
              <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:8 }}>
                <div style={{ fontWeight:700, color:'#0f5132' }}>Ranking de Equipes (Doações Aprovadas)</div>
                <RankingControls />
              </div>
              <div style={{ overflowX:'auto' }}>
                <table style={{ width:'100%', borderCollapse:'collapse' }}>
                  <thead>
                    <tr style={{ textAlign:'left', color:'#495057' }}>
                      <th style={{ padding:8 }}>#</th>
                      <th style={{ padding:8 }}>Equipe</th>
                      <th style={{ padding:8 }}>Alimentos (kg)</th>
                      <th style={{ padding:8 }}>Fundos (R$)</th>
                      <th style={{ padding:8 }}>Brinquedos (un)</th>
                      <th style={{ padding:8 }}>Crescimento 7d</th>
                    </tr>
                  </thead>
                  <tbody>
                    {getRankingRows().map((row, i) => (
                      <tr key={row.team} style={{ borderTop:'1px solid #e9ecef' }}>
                        <td style={{ padding:8 }}>{i+1}</td>
                        <td style={{ padding:8 }}>{row.team}</td>
                        <td style={{ padding:8 }}>{row.food.toFixed(2)}</td>
                        <td style={{ padding:8 }}>{row.funds.toFixed(2)}</td>
                        <td style={{ padding:8 }}>{row.toys}</td>
                        <td style={{ padding:8 }}>
                          {(() => { const g = growthFor(row.team); const sign = g>0?'+':''; return <span className="badge" title="Aprovadas na última semana">{sign}{(g).toFixed(2)}</span>; })()}
                        </td>
                      </tr>
                    ))}
                    {!teamsData.length && (
                      <tr><td colSpan="5" style={{ padding:8, color:'#6c757d' }}>Nenhum registro encontrado</td></tr>
                    )}
                  </tbody>
                </table>
              </div>
            </div>

            {/* Atividade recente */}
            <div className="card anim-fade reveal" style={{ marginTop:16 }}>
              <div className="subtitle" style={{ marginBottom:8 }}>Atividade recente</div>
              <div className="divider"></div>
              {recent.length === 0 ? (
                <div className="muted">Sem eventos recentes</div>
              ) : (
                <div style={{ display:'grid', gap:8 }}>
                  {recent.map((r, idx) => (
                    <div key={idx} style={{ display:'flex', justifyContent:'space-between', alignItems:'center' }}>
                      <div style={{ display:'flex', gap:8, alignItems:'center' }}>
                        <span className="chip">{r.status}</span>
                        <span>{r.description}</span>
                        <span className="muted" style={{ fontSize:12 }}>{r.team || '—'}</span>
                      </div>
                      <span className="muted" style={{ fontSize:12 }}>{new Date(r.updatedAt || r.createdAt).toLocaleString()}</span>
                    </div>
                  ))}
                </div>
              )}
            </div>
            {error && <div style={{ color:'#dc3545', marginTop:8 }}>{error}</div>}
          </div>
        );
      }

      function Card({ children, title, right }) {
        return (
          <div className="card">
            {title && (
              <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:8, color:'#0f5132', fontWeight:700}}>
                <div>{title}</div>
                {right}
              </div>
            )}
            {children}
          </div>
        );
      }

      function LeadersSection() {
        const [leaders, setLeaders] = useState([]);
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState('');
        const [form, setForm] = useState({ name:'', role:'', email:'', team:'' });
        const BASE_URL = (window.__ENV && window.__ENV.API_URL) || 'http://localhost:3001';

        const load = async () => {
          setLoading(true); setError('');
          try {
            const res = await fetch(`${BASE_URL}/api/leaders`);
            const json = await res.json();
            if (!res.ok) throw new Error(json?.message || `Erro HTTP ${res.status}`);
            setLeaders(json.data || []);
          } catch (e) { setError(e.message || 'Erro ao carregar'); }
          finally { setLoading(false); }
        };

        useEffect(() => { load(); }, []);

        const onChange = (e) => setForm(f => ({...f, [e.target.name]: e.target.value}));
        const onSubmit = async (e) => {
          e.preventDefault(); setError('');
          if (!form.name || !form.role || !form.email) { setError('Preencha nome, cargo e email'); return; }
          try {
            const res = await fetch(`${BASE_URL}/api/leaders`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(form) });
            const json = await res.json();
            if (!res.ok) throw new Error(json?.message || 'Erro ao cadastrar');
            setForm({ name:'', role:'', email:'', team:'' });
            await load();
          } catch (e) { setError(e.message || 'Erro ao cadastrar'); }
        };
        const onDelete = async (id) => {
          if (!confirm('Deseja remover este leader?')) return;
          setError('');
          try {
            const res = await fetch(`${BASE_URL}/api/leaders/${id}`, { method:'DELETE' });
            const json = await res.json().catch(()=>({}));
            if (!res.ok) throw new Error(json?.message || 'Erro ao excluir');
            await load();
          } catch (e) { setError(e.message || 'Erro ao excluir'); }
        };

        return (
          <Card title="Cadastro de Leaders" right={<button className="btn" onClick={load}>Atualizar</button>}>
            <form onSubmit={onSubmit} style={{ display:'grid', gridTemplateColumns:'repeat(4, 1fr)', gap:12 }}>
              <input className="input" name="name" placeholder="Nome" value={form.name} onChange={onChange} />
              <input className="input" name="role" placeholder="Cargo" value={form.role} onChange={onChange} />
              <input className="input" name="email" placeholder="Email" value={form.email} onChange={onChange} />
              <input className="input" name="team" placeholder="Equipe (opcional)" value={form.team} onChange={onChange} />
              <div style={{ gridColumn:'1/-1', display:'flex', gap:12, alignItems:'center' }}>
                <button className="btn" type="submit">Cadastrar</button>
                {loading && <span>Carregando…</span>}
                {error && <span style={{ color:'#dc3545' }}>{error}</span>}
              </div>
            </form>

            <div style={{ overflowX:'auto', marginTop:8 }}>
              <table>
                <thead>
                  <tr><th>#</th><th>Nome</th><th>Cargo</th><th>Email</th><th>Equipe</th><th></th></tr>
                </thead>
                <tbody>
                  {!loading && leaders.length === 0 && (
                    <tr><td colSpan="6" style={{ color:'#6c757d' }}>Nenhum registro encontrado</td></tr>
                  )}
                  {leaders.map((l,i) => (
                    <tr key={l.id}>
                      <td>{i+1}</td>
                      <td>{l.name}</td>
                      <td>{l.role}</td>
                      <td>{l.email}</td>
                      <td>{l.team || '-'}</td>
                      <td><button className="btn btn-danger" onClick={()=>onDelete(l.id)}>Excluir</button></td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </Card>
        );
      }

      // Página de Login
      function LoginPage() {
        const { login } = useAuth();
        return <LoginForm onLogin={login} />;
      }

      // Página de Dashboard
      function DashboardPage() {
        const { user, logout } = useAuth();
        
        return (
          <>
            <Header title="Gestão de Lideranças" user={user} onLogout={logout} />
            {user?.role === 'admin' ? (
              <AdminDashboard />
            ) : user?.role === 'mentor' ? (
              <MentorApprovalSection user={user} />
            ) : (
              <StudentDonationsSection user={user} />
            )}
          </>
        );
      }

      function LoginForm({ onLogin }) {
        console.log('📝 LoginForm iniciado');
        const [mode, setMode] = React.useState('login'); // 'login' | 'register'
        const [name, setName] = React.useState("");
        const [email, setEmail] = React.useState("");
        const [password, setPassword] = React.useState("");
        const [confirm, setConfirm] = React.useState("");
        const [role, setRole] = React.useState("aluno");
        const [grupoId, setGrupoId] = React.useState("");
        const [grupos, setGrupos] = React.useState([]);
        const [loadingGrupos, setLoadingGrupos] = React.useState(false);
        const [error, setError] = React.useState("");
        const [showPwd, setShowPwd] = React.useState(true);
        const [remember, setRemember] = React.useState(true);
        
        // Carregar grupos disponíveis quando em modo registro
        React.useEffect(() => {
          if (mode === 'register') {
            loadGrupos();
          }
        }, [mode]);
        
        const loadGrupos = async () => {
          setLoadingGrupos(true);
          try {
            const data = await api.getGrupos();
            console.log('📋 Grupos carregados da API:', data.data);
            setGrupos(data.data || []);
          } catch (error) {
            console.error('❌ Erro ao carregar grupos:', error);
            // Fallback para dados mock em caso de erro
            const gruposMock = [
              { id: 1, nome: 'Equipe Alpha', mentor_id: null },
              { id: 2, nome: 'Equipe Beta', mentor_id: null },
              { id: 3, nome: 'Equipe Gamma', mentor_id: null },
              { id: 4, nome: 'Equipe Delta', mentor_id: null }
            ];
            setGrupos(gruposMock);
          } finally {
            setLoadingGrupos(false);
          }
        };

        const submit = async (e) => {
          e.preventDefault();
          setError("");
          if (mode === 'login') {
            if (!email || !password) { setError('Informe email e senha'); return; }
            
            try {
              const data = await api.login(email, password);
              
              // Login bem-sucedido
              const userData = {
                name: data.data.user.nome,
                email: data.data.user.email,
                role: data.data.user.role,
                team: data.data.user.grupo_nome,
                grupo_id: data.data.user.grupo_id
              };
              
              // Salvar token se disponível
              if (data.data.token) {
                localStorage.setItem('auth_token', data.data.token);
              }
              
              onLogin(userData);
            } catch (error) {
              console.error('Erro no login:', error);
              setError(error.message || 'Erro de conexão. Verifique se o servidor está rodando.');
            }
          } else {
            // Validações para registro
            if (!name || !email || !password || !confirm) { 
              setError('Preencha todos os campos'); 
              return; 
            }
            if (!grupoId) { 
              setError('Selecione um grupo'); 
              return; 
            }
            if (password !== confirm) { 
              setError('As senhas não conferem'); 
              return; 
            }
            if (password.length < 6) { 
              setError('A senha deve ter pelo menos 6 caracteres'); 
              return; 
            }
            
            // Verificar se grupo já tem mentor (se role for mentor)
            if (role === 'mentor') {
              const grupoSelecionado = grupos.find(g => g.id == grupoId);
              if (grupoSelecionado && grupoSelecionado.mentor_id) {
                setError('Este grupo já possui um mentor. Escolha outro grupo.');
                return;
              }
            }
            
            try {
              const data = await api.register({
                nome: name,
                email: email,
                senha: password,
                role: role,
                grupo_id: grupoId
              });
              
              // Registro bem-sucedido
              const userData = {
                name: data.data.user.nome,
                email: data.data.user.email,
                role: data.data.user.role,
                team: data.data.user.grupo_nome,
                grupo_id: data.data.user.grupo_id
              };
              
              // Salvar token se disponível
              if (data.data.token) {
                localStorage.setItem('auth_token', data.data.token);
              }
              
              onLogin(userData);
            } catch (error) {
              console.error('Erro no registro:', error);
              setError(error.message || 'Erro de conexão. Verifique se o servidor está rodando.');
            }
          }
        };

        const Title = () => (
          <div className="login-title">
            Gestão de Doações - Lideranças Empáticas
          </div>
        );

        return (
          <div className="login-wrapper">
            <div className="login-card anim-scale">
              <div className="login-header anim-fade">
                <div className="login-logos">
                  <img className="auth-logo-lg" src="./public/logos/logo1.png" alt="Lideranças Empáticas" />
                  <img className="auth-logo-sm" src="./public/logos/logo2.png" alt="FECAP" />
                </div>
                <Title />
                <div className="login-subtitle">Gestão inteligente de doações em tempo real</div>
              </div>
              <form onSubmit={submit} className="login-form anim-fade">
                {mode === 'register' && (
                  <>
                    <input className="input" placeholder="Nome completo" value={name} onChange={(e)=>setName(e.target.value)} required />
                    <input className="input" type="email" placeholder="Email" value={email} onChange={(e)=>setEmail(e.target.value)} required />
                    <select className="input" value={role} onChange={(e)=>setRole(e.target.value)} required>
                      <option value="aluno">Aluno</option>
                      <option value="mentor">Mentor</option>
                    </select>
                    <select className="input" value={grupoId} onChange={(e)=>setGrupoId(e.target.value)} required style={{borderColor: !grupoId ? '#ff6b6b' : ''}} disabled={loadingGrupos}>
                      <option value="">{loadingGrupos ? 'Carregando grupos...' : 'Selecione um grupo *'}</option>
                      {grupos.map(grupo => (
                        <option key={grupo.id} value={grupo.id} disabled={role === 'mentor' && grupo.mentor_id}>
                          {grupo.nome} {role === 'mentor' && grupo.mentor_id ? '(Já tem mentor)' : ''}
                        </option>
                      ))}
                    </select>
                    {role === 'mentor' && (
                      <div style={{fontSize: '0.85rem', color: '#4df2c2', marginTop: '-10px', marginBottom: '10px'}}>
                        💡 Como mentor, você será automaticamente atribuído ao grupo selecionado
                      </div>
                    )}
                    {!grupoId && (
                      <div style={{fontSize: '0.85rem', color: '#ff6b6b', marginTop: '-10px', marginBottom: '10px'}}>
                        ⚠️ Seleção de grupo é obrigatória
                      </div>
                    )}
                    <div className="input-group">
                      <input
                        className="input"
                        type={showPwd ? 'text' : 'password'}
                        placeholder="Senha"
                        value={password}
                        onChange={(e)=>setPassword(e.target.value)}
                      />
                      <button
                        type="button"
                        className="link-ghost"
                        style={{ position:'absolute', right:12, top:'50%', transform:'translateY(-50%)', color:'#4df2c2' }}
                        onClick={()=>setShowPwd(v=>!v)}
                      >
                        {showPwd ? 'Ocultar' : 'Mostrar'}
                      </button>
                    </div>
                    <div className="input-group">
                      <input
                        className="input"
                        type={showPwd ? 'text' : 'password'}
                        placeholder="Confirmar senha"
                        value={confirm}
                        onChange={(e)=>setConfirm(e.target.value)}
                      />
                      <button
                        type="button"
                        className="link-ghost"
                        style={{ position:'absolute', right:12, top:'50%', transform:'translateY(-50%)', color:'#4df2c2' }}
                        onClick={()=>setShowPwd(v=>!v)}
                      >
                        {showPwd ? 'Ocultar' : 'Mostrar'}
                      </button>
                    </div>
                  </>
                )}
                {mode === 'login' && (
                  <>
                    <input className="input" type="email" placeholder="Email" value={email} onChange={(e)=>setEmail(e.target.value)} />
                    <select className="input" value={role} onChange={(e)=>setRole(e.target.value)}>
                      <option value="aluno">Aluno</option>
                      <option value="mentor">Mentor</option>
                      <option value="admin">Admin (Apenas para administradores)</option>
                    </select>
                    <div className="input-group">
                      <input
                        className="input"
                        type={showPwd ? 'text' : 'password'}
                        placeholder="Senha"
                        value={password}
                        onChange={(e)=>setPassword(e.target.value)}
                      />
                      <button
                        type="button"
                        className="link-ghost"
                        style={{ position:'absolute', right:12, top:'50%', transform:'translateY(-50%)', color:'#4df2c2' }}
                        onClick={()=>setShowPwd(v=>!v)}
                      >
                        {showPwd ? 'Ocultar' : 'Mostrar'}
                      </button>
                    </div>
                  </>
                )}
                {error && <span className="login-error">{error}</span>}
                <div className="login-actions">
                  <button className="btn btn-full" type="submit">
                    {mode === 'login' ? 'Entrar' : 'Criar Conta'}
                  </button>
                  <div className="login-switch">
                    {mode === 'login' ? (
                      <button className="btn" type="button" onClick={()=>{ setError(''); setMode('register'); }}>Criar Conta</button>
                    ) : (
                      <button className="btn" type="button" onClick={()=>{ setError(''); setMode('login'); }}>Já tenho conta</button>
                    )}
                  </div>
                </div>
              </form>
            </div>
          </div>
        );
      }

      // Componente principal com roteamento
      function App() {
        const { route } = useRouter();
        const { user, loading } = useAuth();
        
        if (loading) {
          return (
            <div style={{ 
              display: 'flex', 
              justifyContent: 'center', 
              alignItems: 'center', 
              height: '100vh',
              color: '#4df2c2'
            }}>
              <div>Carregando...</div>
            </div>
          );
        }
        
        // Roteamento baseado na rota atual
        switch (route) {
          case '/login':
            return <LoginPage />;
          case '/dashboard':
            return (
              <ProtectedRoute user={user}>
                <DashboardPage />
              </ProtectedRoute>
            );
          case '/admin':
            return (
              <ProtectedRoute user={user} requiredRole="admin">
                <AdminPage />
              </ProtectedRoute>
            );
          default:
            // Redirecionamento baseado no estado do usuário
            if (user) {
              Router.navigate('/dashboard');
            } else {
              Router.navigate('/login');
            }
            return null;
        }
      }

      // Página específica do Admin
      function AdminPage() {
        const { user, logout } = useAuth();
        
        return (
          <>
            <Header title="Gestão de Lideranças - Admin" user={user} onLogout={logout} />
            <AdminDashboard />
          </>
        );
      }


      // Função para mostrar erros na tela
      function ErrorBoundary({ children }) {
        const [hasError, setHasError] = useState(false);
        const [error, setError] = useState(null);
        
        useEffect(() => {
          const errorHandler = (errorEvent) => {
            setHasError(true);
            setError(errorEvent.error || 'Ocorreu um erro desconhecido');
            console.error('Erro capturado:', errorEvent.error);
            return false;
          };
          
          window.addEventListener('error', errorHandler);
          return () => window.removeEventListener('error', errorHandler);
        }, []);
        
        if (hasError) {
          return (
            <div style={{
              padding: '20px',
              color: 'white',
              backgroundColor: '#ff4444',
              fontFamily: 'monospace',
              whiteSpace: 'pre-wrap',
              maxWidth: '800px',
              margin: '0 auto',
              borderRadius: '8px',
              boxShadow: '0 0 10px rgba(0,0,0,0.5)'
            }}>
              <h2>⚠️ Ocorreu um erro na aplicação</h2>
              <p>Por favor, recarregue a página. Se o problema persistir, entre em contato com o suporte.</p>
              <details style={{ marginTop: '10px' }}>
                <summary>Detalhes do erro</summary>
                <div style={{
                  backgroundColor: 'rgba(0,0,0,0.2)',
                  padding: '10px',
                  marginTop: '10px',
                  borderRadius: '4px',
                  overflowX: 'auto'
                }}>
                  {error && error.toString()}
                  {error && error.stack && (
                    <pre style={{ margin: '10px 0 0 0' }}>{error.stack}</pre>
                  )}
                </div>
              </details>
              <button 
                onClick={() => window.location.reload()}
                style={{
                  marginTop: '15px',
                  padding: '8px 16px',
                  background: 'white',
                  border: 'none',
                  borderRadius: '4px',
                  cursor: 'pointer',
                  fontWeight: 'bold'
                }}
              >
                Recarregar Página
              </button>
            </div>
          );
        }
        
        return children;
      }

      // Função para limpar todos os dados locais (para testes)
      window.clearAllData = function() {
        if (confirm('⚠️ Isso irá limpar TODOS os dados locais. Continuar?')) {
          localStorage.clear();
          sessionStorage.clear();
          console.log('🧹 Todos os dados locais foram limpos!');
          alert('✅ Dados locais limpos! A página será recarregada.');
          window.location.reload();
        }
      };
      
      // Sistema de depuração e renderização da aplicação
      console.log('🚀 Iniciando aplicação...');
      console.log('React:', typeof React);
      console.log('ReactDOM:', typeof ReactDOM);
      console.log('useState:', typeof useState);
      console.log('useEffect:', typeof useEffect);
      console.log('useRef:', typeof useRef);
      console.log('LS_KEYS:', LS_KEYS);
      console.log('lsGet function:', typeof lsGet);
      console.log('lsSet function:', typeof lsSet);
      console.log('💡 Para limpar dados locais, execute: clearAllData()');
      
      // Verifica se o elemento root existe
      const rootElement = document.getElementById('root');
      console.log('Elemento root encontrado:', !!rootElement);
      
      if (!rootElement) {
        document.body.innerHTML = `
          <div style="padding:20px;color:white;background:#ff4444;font-family:monospace;">
            <h2>❌ Erro: Elemento 'root' não encontrado</h2>
            <p>O elemento com id='root' não foi encontrado no DOM.</p>
          </div>
        `;
        throw new Error('Elemento root não encontrado');
      }

      // Renderização da aplicação com tratamento de erros
      try {
        console.log('📦 Criando root do React...');
        
        // Verifica se todas as dependências estão disponíveis
        if (typeof React === 'undefined') {
          throw new Error('React não está carregado');
        }
        if (typeof ReactDOM === 'undefined') {
          throw new Error('ReactDOM não está carregado');
        }
        if (typeof useState === 'undefined') {
          throw new Error('useState não está disponível');
        }
        if (typeof useEffect === 'undefined') {
          throw new Error('useEffect não está disponível');
        }
        if (typeof useRef === 'undefined') {
          throw new Error('useRef não está disponível');
        }
        
        const root = ReactDOM.createRoot(rootElement);
        
        console.log('🎨 Renderizando aplicação...');
        
        // Renderização com roteamento
        root.render(
          <ErrorBoundary>
            <App />
          </ErrorBoundary>
        );
        
        console.log('✅ Aplicação renderizada com sucesso!');
        
      } catch (error) {
        console.error('❌ Erro ao renderizar a aplicação:', error);
        rootElement.innerHTML = `
          <div style="padding:20px;color:white;background:#ff4444;font-family:monospace;">
            <h2>❌ Erro ao carregar a aplicação</h2>
            <p><strong>Erro:</strong> ${error.message}</p>
            <p><strong>Stack:</strong></p>
            <pre style="background:rgba(0,0,0,0.2);padding:10px;border-radius:4px;overflow:auto;">${error.stack}</pre>
            <button onclick="window.location.reload()" style="margin-top:10px;padding:8px 16px;background:white;color:black;border:none;border-radius:4px;cursor:pointer;">
              🔄 Recarregar Página
            </button>
          </div>
        `;
      }
    </script>
  </body>
</html>
